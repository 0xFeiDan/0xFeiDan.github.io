<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>“Oh Ottie!” 12 月 NFT 收藏Drop：今天加入白名单！</title>
      <link href="/2022/11/08/%E2%80%9COh%20Ottie!%E2%80%9D%2012%20%E6%9C%88%20NFT%20%E6%94%B6%E8%97%8FDrop%EF%BC%9A%E4%BB%8A%E5%A4%A9%E5%8A%A0%E5%85%A5%E7%99%BD%E5%90%8D%E5%8D%95%EF%BC%81/"/>
      <url>/2022/11/08/%E2%80%9COh%20Ottie!%E2%80%9D%2012%20%E6%9C%88%20NFT%20%E6%94%B6%E8%97%8FDrop%EF%BC%9A%E4%BB%8A%E5%A4%A9%E5%8A%A0%E5%85%A5%E7%99%BD%E5%90%8D%E5%8D%95%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<ul><li>Mint哦，“Oh Ottie!” 使用从以太坊、BNB 链和多边形桥接的原生资产</li><li>从 11 月 8 日至 12 月 4 日<a href="https://sograph.xyz/space/altlayer/campaign/yVFDYdj1ao">在此处</a>阅读说明和白名单</li></ul><p><img src="https://miro.medium.com/max/700/0*XsATzSYhmCGkBK8_.png" alt="img"></p><p>我们有一些令人兴奋的消息要告诉你。自从我们向大家介绍我们可爱的吉祥物 Ottie 以来，我们收到了很好的反馈，我们决定发布一个包含 2,000 个独特 Ottie 头像的集合，作为名为<strong>“ *Oh Ottie*！”的 NFT 集合的一部分。</strong></p><p>每个化身都代表着Ottie的不同方面 — — 无论是爱好、职业还是情绪！他们每个人都将需要特殊的权利和特权。</p><p>类似于 OG 徽章drop，*<strong>Oh Ottie*！</strong>mint 将展示 Altlayer 卓越的 flashlayer 技术，该技术可以跨 EVM 和非 EVM 链以无气体方式进行 NFT 铸造。</p><p>但这一次，我们将其提升到一个新的水平。*<strong>Oh Ottie*！</strong>NFT 可以使用从以太坊、BNB 链和 Polygon 桥接的原生资产铸造，并最终将资产汇总到以太坊进行交易。</p><h1 id="总供应量"><a href="#总供应量" class="headerlink" title="总供应量"></a>总供应量</h1><p><strong>Oh Ottie</strong>系列的2,000个头像中:</p><ul><li>12 月 9 日将在我们的 flashlayer 上以 0.08 ETH 或等值的价格铸造 1,200 个</li><li>420 将在铸币活动之前空投给现有的 OG Badge NFT 持有者</li><li>180个将在薄荷活动前分发给合作项目和社区进行幸运抽奖</li><li>200个头像将专门保留用于未来的社区参与和合作伙伴使用</li></ul><h1 id="为什么要购买-Oh-Ottie-NFT？"><a href="#为什么要购买-Oh-Ottie-NFT？" class="headerlink" title="为什么要购买 Oh Ottie NFT？"></a>为什么要购买 Oh Ottie NFT？</h1><p>我们将通过在线和离线参与以及社会影响活动与我们的社区分享我们对 Ottie 的热爱。以下是<strong>Oh Ottie 的一些特权！</strong>持有人。</p><ul><li>未来clim代币&#x2F;NFT 空投</li><li>独家访问商品和线下活动</li><li>优先访问测试网验证程序</li><li>AltLayer 将代表社区在全球动物园收养和赞助水獭，包括但不限于新加坡动物园</li></ul><h1 id="重要的日子"><a href="#重要的日子" class="headerlink" title="重要的日子"></a>重要的日子</h1><ul><li><strong>白名单于11 月 8 日</strong>SGT 晚上 18:00 开始，并于<strong>12 月 4 日</strong>下午 23:59 SGT 结束。</li><li>12月<strong>7 日，</strong>我们将发布mint指南，并为您打开***单向桥***，将您的 ETH、BNB 和 Matic 代币转移到我们的 flashlayer。</li></ul><p>请注意，只有一个 flashlayer rollup 跨越以太坊、BNB 链和多边形，并支持 ETH、BNB 和 Matic 代币。用户可以选择一种或多种代币类型（ETH、BNB 和 Matic）来铸造，只要您在我们的 flashlayer 上有足够的相关代币余额即可。</p><p>另请注意，在铸币活动结束之前，您***将无法***在我们的 flashlayer 上提取您的桥接代币资产。请注意用于铸造的代币数量。</p><h1 id="Mint事件"><a href="#Mint事件" class="headerlink" title="Mint事件"></a>Mint事件</h1><p>薄荷事件持续 24 小时，分为两部分。</p><p>*<strong>第 1 部分 — 私人Mint：*</strong> 12 月 9 日，我们将在 12.00 PM — 16.00 PM SGT 之间开始对列入白名单的地址进行私人铸币。</p><p>***第 2 部分 — — 公共Mint：***公共铸币厂对所有人开放。它从 12 月 9 日 SGT 下午 16 点开始，持续接下来的 20 个小时。单向桥将保持开放，直到铸币厂活动结束。</p><ul><li>当所有 1,200 个头像全部铸造完毕或 24 小时铸造期结束时，铸造活动结束。</li><li>无论使用何种代币，每个钱包地址最多可以铸造 10 个头像。</li><li>请注意，我们的 flashlayer 仅支持 $ETH、$BNB 和 Matic 代币。您将无法跨越其他令牌。</li></ul><h1 id="Mint后事件"><a href="#Mint后事件" class="headerlink" title="Mint后事件"></a>Mint后事件</h1><ul><li>铸币活动结束后，我们将通过汇总过程自动将所有铸币化身桥接回以太坊，并将所有剩余的代币资产桥接回以太坊、BNB 链和多边形。您不必自己将资产桥接到 L1。</li><li>在以太坊主网上收到您铸造的头像后，您将能够交易<strong>Oh Ottie！</strong>Opensea、Looksrare、X2Y2 和 Blur 等的合集</li></ul><h1 id="您如何获得空投资格？"><a href="#您如何获得空投资格？" class="headerlink" title="您如何获得空投资格？"></a>您如何获得空投资格？</h1><p>如果您是我们现有的 OG Badge NFT 的持有者，您只需坐好，就会自动收到<strong>Oh Ottie 的空投！</strong>在我们的薄荷事件之前的头像。我们将在稍后披露包括快照时间在内的详细信息。</p><h1 id="你怎么能有资格参加薄荷活动？"><a href="#你怎么能有资格参加薄荷活动？" class="headerlink" title="你怎么能有资格参加薄荷活动？"></a>你怎么能有资格参加薄荷活动？</h1><p>您可以增加获得<strong>Oh Ottie 的几率！通过加入白名单过程</strong>来创建头像。</p><p><a href="https://sograph.xyz/space/altlayer/campaign/yVFDYdj1ao">请在此</a>页面上完成以下任务。</p><ul><li>在推特上关注 <a href="https://twitter.com/alt_layer">Yaoqi Jia</a></li><li>在 Twitter 上关注<a href="https://twitter.com/alt_layer">Altlayer</a></li><li>喜欢并转发固定的<strong>Oh Ottie!！</strong> <a href="https://twitter.com/alt_layer/status/1589918467377205248">公告</a></li><li>加入我们的<a href="https://discord.gg/altlayer">Discord 服务器</a>并完成必要的步骤</li><li>连接你的以太坊钱包地址</li></ul><p>让白名单开始吧！</p>]]></content>
      
      
      <categories>
          
          <category> AltLayer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AltLayer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Axelar 与 Polygon 合作，为 Polygon Supernets 提供跨链通信</title>
      <link href="/2022/10/30/Axelar%20%E4%B8%8E%20Polygon%20%E5%90%88%E4%BD%9C%EF%BC%8C%E4%B8%BA%20Polygon%20Supernets%20%E6%8F%90%E4%BE%9B%E8%B7%A8%E9%93%BE%E9%80%9A%E4%BF%A1/"/>
      <url>/2022/10/30/Axelar%20%E4%B8%8E%20Polygon%20%E5%90%88%E4%BD%9C%EF%BC%8C%E4%B8%BA%20Polygon%20Supernets%20%E6%8F%90%E4%BE%9B%E8%B7%A8%E9%93%BE%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>Axelar是Polygon Supernets的早期采用者之一，它将扩大Polygon Supernets的互操作性–高性能的应用专用链，可以为某个dApp或某类dApp进行优化。</strong></p></blockquote><p><strong><img src="https://images.ctfassets.net/mjqoq33y05of/6CiFklZ0qcemxLNdoKDxJC/dd2ce50107d4225fe3978a00616f3e49/AXL-MATIC.jpg" alt="img"></strong></p><p><strong>Axelar 是连接 Web3 生态系统的权益证明区块链，它正在与<a href="https://polygon.technology/">Polygon</a>合作，为 Polygon Supernets 提供安全的跨链通信，作为由 Polygon Edge 提供支持的专用 EVM 区块链的可互操作互联网的核心基础设施。一旦与 Axelar 集成，每个 Supernet 将能够安全地在其他 Supernet 和任何其他连接链之间转移资产。</strong> </p><p><strong>简而言之，Axelar 是 Polygon Supernets 的早期采用者之一，它将扩展 Polygon Supernets 的互操作性——可以针对 dApp 或一类 dApps 进行优化的高性能应用程序特定链。</strong> </p><p><strong>“Axelar 的跨链基础设施将使开发人员能够在 Polygon Edge 上构建跨链 dApp，这些 dApp 构成了跨 Web3 的流动性和功能，”Polygon Supernets总经理 Parth Pathak 说。“这使得复杂的操作成为可能——例如，使用 NFT 作为抵押品的跨链借贷。Polygon Supernets 正在通过一键式体验的多链大规模采用，为游戏、企业、NFT 和 DeFi 的用户创建世界领先的互联 Web3 生态系统。”</strong></p><p><strong>具体来说，Axelar 支持具有以下功能的开发人员，以实现快速、简单的入职：</strong></p><ul><li><strong>Polygon Supernets 将把他们的原生 gas 代币无缝地放入用户钱包中——从以太坊或 Polygon 上的用户钱包中一键点击。</strong></li><li><strong>Axelar 的 SDK 将使 Supernet dApps 能够生成一次性存款地址——与中心化交易所一样，与链无关。</strong></li><li><strong>Supernets之间的简单流动性路径：由于这种简单的跨链流动性解决方案，每个Supernets都不需要拥有自己的 dex。</strong> </li><li><strong>每个 Supernet 都可以在几天内与 Axelar 集成。集成后，dApp 可以通过简单的 API 请求轻松地与所有连接的链进行通信。</strong></li></ul><p><strong>Axelar 的联合创始人 Sergey Gorbunov 表示：“由于这种合作关系，基于 Polygon 构建的 dApp 的用户将能够访问领先的元界、游戏、企业、Defi 和娱乐项目中最令人兴奋的专用区块链 dApp。” “与其他现有的 L1 和 L2 相比，Supernet 链为用户提供了快速的用户体验，同时 Gas 费用显着降低。用户可以轻松地在多个 Supernet 链中移动和使用他们的货币和 NFT，从而为多链 Web3 生态系统打开了可能性。”</strong></p><p><strong>关于Axelar：</strong></p><p><strong>Axelar 提供安全的跨链通信，使 dApp 用户能够一键与任何链上的任何资产或应用程序进行交互。简而言之，Axelar 适用于 Web3，就像 Stripe 适用于移动和互联网应用程序一样。Axelar 已从包括 Dragonfly Capital、Polychain Capital、Coinbase 和 Binance 在内的顶级投资者那里筹集资金。合作伙伴包括主要的权益证明区块链，例如 Avalanche、Cosmos、以太坊、Polkadot 等。Axelar 的联合创始人 Sergey Gorbunov 和 Georgios Vlachos 是 Algorand 的创始团队成员。</strong></p><p><strong>有关 Axelar 的更多信息：<a href="https://docs.axelar.dev/?utm_source=businesswire&utm_medium=pr&utm_campaign=polygon">docs.axelar.dev</a> | <a href="https://axelar.network/?utm_source=businesswire&utm_medium=pr&utm_campaign=polygon">axelar.network</a> | <a href="https://github.com/axelarnetwork/axelar-local-gmp-examples">GitHub</a> | <a href="https://discord.com/invite/aRZ3Ra6f7D">不和谐</a>| <a href="https://twitter.com/axelarcore">推特</a>。</strong></p><p><strong>关于多边形</strong></p><p><strong><a href="https://polygon.technology/">Polygon</a>是领先的区块链开发平台，为 Web3 提供可扩展、负担得起、安全和可持续的区块链。其不断增长的产品套件使开发人员可以轻松访问主要的扩展解决方案，包括 L2（ZK Rollups 和 Optimistic Rollups）、侧链、混合、独立和企业链以及数据可用性。Polygon 的扩展解决方案已得到广泛采用，唯一用户地址超过 1.749 亿。该网络是 Aave、Uniswap、OpenSea 等一些最大的 Web3 项目以及星巴克、Meta、Stripe 和 Adobe 等知名企业的所在地。Polygon 是碳中和的，其目标是引领 Web3 生态系统成为碳负的。</strong></p><p><strong>如果您是以太坊开发人员，那么您已经是 Polygon 开发人员了！为您的 dApp 使用 Polygon 快速且安全的 txns，从<a href="https://docs.polygon.technology/docs/develop/getting-started">这里</a>开始。</strong></p><p><strong><a href="https://polygon.technology/">网站</a>| <a href="https://twitter.com/intent/user?screen_name=0xPolygon">推特</a>| <a href="https://twitter.com/intent/user?screen_name=0xPolygonNews">生态系统推特</a>| <a href="https://twitter.com/intent/user?screen_name=0xPolygonDevs">开发者推特</a>| <a href="https://twitter.com/intent/user?screen_name=polygonstudios">工作室推特</a>| <a href="https://t.me/polygonofficial">电报</a>| <a href="https://www.linkedin.com/company/13449964/admin/">领英</a>| <a href="https://www.reddit.com/r/0xpolygon/">书签交易</a>| <a href="https://discord.gg/XvpHAxZ">不和谐</a>| <a href="https://www.instagram.com/0xpolygon/">Instagram</a> | <a href="https://www.facebook.com/0xPolygon.Technology">Facebook</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> Axelar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Axelar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>介绍Linera</title>
      <link href="/2022/10/30/%E4%BB%8B%E7%BB%8DLinera/"/>
      <url>/2022/10/30/%E4%BB%8B%E7%BB%8DLinera/</url>
      
        <content type="html"><![CDATA[<h1 id="将web2的性能和可靠性引入web3"><a href="#将web2的性能和可靠性引入web3" class="headerlink" title="将web2的性能和可靠性引入web3"></a><strong>将web2的性能和可靠性引入web3</strong></h1><p><img src="https://miro.medium.com/max/700/1*kPq71LOX3wioySgTkb-yqw.jpeg" alt="img"></p><blockquote><p>原文：<a href="https://medium.com/@linera/introducing-linera-bdb809735552">https://medium.com/@linera/introducing-linera-bdb809735552</a></p><p>翻译人：FeiDan</p></blockquote><p>Hello World! 现在我想向大家介绍 Linera，这个我创建的项目，其使命是创建<strong>第一个可以像 web2 应用程序一样轻松扩展的低延迟区块链</strong>。</p><p>在 Meta&#x2F;Novi 工作期间，我有幸从事分布式系统的最新研究。我对旨在彻底改变区块链可扩展性的两种协议特别感兴趣：<a href="https://arxiv.org/pdf/2003.11506.pdf">FastPay</a>和<a href="https://linera.io/s/zef.pdf">Zef</a>。作为一名基础设施工程师，我迫不及待地将这些想法付诸实践，但很明显，这样一个雄心勃勃的项目需要专门的结构和适当的资金支持。</p><h1 id="为什么我们需要低延迟区块链"><a href="#为什么我们需要低延迟区块链" class="headerlink" title="为什么我们需要低延迟区块链"></a>为什么我们需要低延迟区块链</h1><p>是区块链历来最重借出的功能就是在用例中表现出色的“抗审查性”。然而，越来越多的应用也需要低延迟—即，可预测的，响应用户操作的低确认时间。此类用例包括：零售支付、游戏的小额支付、自营交易以及区块链之间跨链。不幸的是，由于内存池的开销和验证者之间的复杂协调，最快区块链中的确认时间通常仍然需要几秒钟。</p><p>我参与的 <a href="https://arxiv.org/pdf/2003.11506.pdf">FastPay</a> 和 <a href="https://linera.io/papers/zef.pdf">Zef</a> 的学术工作表明，简单的操作，如支付，通过完全移除内存池和最小化验证者之间的交互，可以大大加快速度。在这一系列协议中，区块链客户端直接与验证者通信来提交和确认新账户操作。</p><p>Linera 区块链旨在推广这种方法并将其投入实际生产，<strong>使大多数基于帐户的操作能够在几分之一秒内得到确认</strong>。</p><h1 id="线性扩展的案例"><a href="#线性扩展的案例" class="headerlink" title="线性扩展的案例"></a>线性扩展的案例</h1><p>现今，大型互联网应用是从头开始构建的，并已经考虑了可扩展性。用户依赖互联网进行日常活动，例如导航、购物和视频。它们对速度慢或服务中断的容忍度非常低。</p><p>Web2 应用并不总是能达到这样的可扩展性和可靠性水平。可以说，这一突破来自于 2000 年代行业向一种称为“线性扩展”的严格水平扩展形式的转变。数据库社区<a href="https://redis.com/redis-enterprise/technology/linear-scaling-redis-enterprise">解释得很好</a>：线性扩展意味着总是可以通过将系统的容量翻倍来翻倍机器数量。</p><p>到目前为止，区块链优先考虑“序列”执行模型，该模型允许用户账户和智能合约在一系列交易中进行任意交互（例如闪电贷）。不幸的是，序列执行阻止了线性扩展。 <strong>我们认为，与数据库从 SQL 到 NoSQL 的演变相类似的范式转变，对于未来的去中心化系统提供任意规模的低延迟保证是必要的。</strong></p><p>Linera 项目将开发和推广适用于线性扩展的全新的执行模型。在这样的模型中，默认情况下，对不同用户帐户的操作将同时运行——即在不同的执行线程中。通过这种方式，始终可以通过向每个验证者添加新的处理单元来扩展执行。在传统的 web2 架构中，这些额外的处理单元（称为“worker”或“shards”）由数据中心或云提供商按需提供。</p><h1 id="等等，如果验证者是数据中心，这仍然是一个去中心化协议吗？"><a href="#等等，如果验证者是数据中心，这仍然是一个去中心化协议吗？" class="headerlink" title="等等，如果验证者是数据中心，这仍然是一个去中心化协议吗？"></a>等等，如果验证者是数据中心，这仍然是一个去中心化协议吗？</h1><p>现在，经典的“区块链困难三角”断言了同时实现可扩展性、安全性和去中心化的极高难度。这一观察虽然适用于固定规模的验证者，但我们认为在为大型、高吞吐量验证者进行定义和实施令人满意的去中心化概念方面，所做的努力还不够。特别是，使用硬件，审计高吞吐量系统历来具有挑战性，因为单个审计员不可能运行所有交易。</p><p><strong>我们的目标是使用最先进的共识证明机制(state-of-the-art proof-of-stake mechanisms)和可扩展的审计程序来确保 Linera 协议的去中心化，以确保验证者全面承担责任。</strong></p><p>为了支持社区的大规模审计，我们打算利用 Linera 的并发模型。同样，我们也在密切关注有效性证明领域取得的快速持续进展。</p><h1 id="这仅仅是开始"><a href="#这仅仅是开始" class="headerlink" title="这仅仅是开始"></a>这仅仅是开始</h1><p>我们目前正致力于实施 Linera 协议以及迈向开源发布的第一步。</p><p>我们的团队包括工程师和研究人员（前 Zcash、前 Meta&#x2F;Novi、伦敦城市大学）在 web2 和 web3 方面具有强大的技术背景。我们相信，这种技能组合使我们具有独特的优势，可以实现我们的愿景，为去中心化应用带来高性能和高可靠性。</p><h1 id="我们正在招聘"><a href="#我们正在招聘" class="headerlink" title="我们正在招聘"></a>我们正在招聘</h1><p>我们对区块链技术、分布式系统和 Rust 编程语言充满热情。访问我们的 <a href="https://linera.io/">网站</a>，在 <a href="https://twitter.com/linera_io">Twitter</a> 上关注我们，或 <a href="mailto:contact@linera.io">给我们留言</a>了解更多关于我们的空缺职位。</p><p>—Linera 创始人兼首席执行官 Mathieu Baudet</p>]]></content>
      
      
      <categories>
          
          <category> Linera </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linera </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么区块链的互通性很重要–以及如何安全地实现它</title>
      <link href="/2022/10/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E4%BA%92%E9%80%9A%E6%80%A7%E5%BE%88%E9%87%8D%E8%A6%81--%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E5%9C%B0%E5%AE%9E%E7%8E%B0%E5%AE%83/"/>
      <url>/2022/10/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E4%BA%92%E9%80%9A%E6%80%A7%E5%BE%88%E9%87%8D%E8%A6%81--%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E5%9C%B0%E5%AE%9E%E7%8E%B0%E5%AE%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>区块链的互通性必须是所有Web3开发者的优先事项。为用户提供一种安全和简单的方式在多个区块链上进行交易，对Web3应用程序和协议的增长和可扩展性非常重要。</strong></p></blockquote><p><strong>Web3的增长离不开开发者和用户体验的改善。随着更多区块链的推出，开发者和用户的复杂性都在增加。开发人员需要学习新的语言并在新的环境中工作。用户需要管理多个钱包，并使用有风险的跨链桥桥来与他们在不同链上的资产进行互动。</strong></p><p><strong>为了减少这种复杂性，区块链的互通性必须成为所有Web3开发者的优先事项。给用户提供一个安全和简单的方式在多个区块链上进行交易，对于Web3应用程序和协议的增长和可扩展性非常重要。</strong></p><p><strong>这有时会感觉是一项压倒性的任务。作为一个开发者，你面临着许多不同的互通性的路径。确保你选择适合你的项目的正确方法，需要你没有的时间。做出错误的决定会导致时间的浪费和技术债务。</strong></p><p><strong>为了帮助你做出一个明智的决定，让我们先看看为什么互通性很重要，然后回顾一些已知的区块链互通性的方法及其使用案例。</strong></p><h2 id="为什么区块链的互通性很重要"><a href="#为什么区块链的互通性很重要" class="headerlink" title="为什么区块链的互通性很重要"></a><strong>为什么区块链的互通性很重要</strong></h2><p><strong><a href="https://medium.com/dragonfly-research/axelar-bridges-and-blockchain-globalization-11ef3bbce9f1">与全球化相比，</a>区块链互通性是因为它能够打开当前锁定在某些链中的资产流动。与国家一样，区块链在某些领域的专业化和表现优于其他领域。对于某些应用程序，链在去中心化环境中提供可扩展性和安全性的位置非常重要。</strong> </p><p><strong><img src="https://images.ctfassets.net/mjqoq33y05of/3y0LNEYVq7ssms894uZzjB/8b95df04a5696b569bff3a84daaebfda/axelelarscan.gif" alt="img"></strong></p><p><strong>开放专业区块链之间的流动不仅仅是为现有应用程序的发展创造机会。它为新的应用程序和用例的出现创造了机会。这方面的例子在整个经济史上比比皆是，从<a href="https://medium.com/dragonfly-research/axelar-bridges-and-blockchain-globalization-11ef3bbce9f1">随着全球化出现</a>的新业务类别，到随着<a href="https://axelar.network/blog/5790-2">覆盖网络</a>的出现而兴起的新互联网业务类别，这增加了网络上的互通性。</strong> </p><h2 id="互通性的传统方法"><a href="#互通性的传统方法" class="headerlink" title="互通性的传统方法"></a><strong>互通性的传统方法</strong></h2><p><strong>跨链解决方案不是将自己锁定在一条链及其可用合约上，而是为应用程序及其用户打开了 Web3 世界。许多开发人员已经认识到这一点，因此有两条陈旧的互通性途径：多重部署和跨链桥接。在这里，我们将看看这些方法的不足之处。</strong> </p><h3 id="多重部署——艰难的道路"><a href="#多重部署——艰难的道路" class="headerlink" title="多重部署——艰难的道路"></a><strong>多重部署——艰难的道路</strong></h3><p><strong>将多个智能合约部署到连接到您的应用程序的不同区块链网络是互通性的一种策略。例如，您可以在以太坊和 Solana 上构建一个具有智能合约的应用程序。这允许用户选择他们喜欢的链来使用您的应用程序，这是区块链互通性的目标之一。</strong> </p><p><strong>用户似乎通过这种方法得到了他们想要的东西，但从开发人员的角度来看，这种“多代码”策略并非没有成本。维护应用程序的整个副本可能会导致管理通用应用程序状态、设计类似的用户体验以及跨不同链跟踪更新的问题。</strong> </p><p><strong>即使对于克服这些挑战的项目，开发人员无法控制的网络效应也会干扰用户体验。通常，多代码项目最终以一个或多个区块链用户为二等公民，例如，流动性低于领先链。这对那些用户和世界来说，对 dApp 的影响很差。</strong> </p><p><strong>根据您的应用程序，这些缺点可能会成为阻碍因素。多代码方法通过使应用程序可跨多个链访问来实现互通性，但无法为应用程序跨多个链进行通信提供任何方式。最终，即使对于最有经验的开发人员来说，跨具有不同架构和功能的多个区块链管理代码也是不可扩展的。</strong> </p><h2 id="跨链桥——冒险的方式"><a href="#跨链桥——冒险的方式" class="headerlink" title="跨链桥——冒险的方式"></a><strong>跨链桥——冒险的方式</strong></h2><p><strong>通过将跨链通信直接引入您的应用程序，跨链桥在多代码策略失败的情况下取得成功。跨链桥通过为用户跨链转移代币来工作。用户将金额发送到源区块链上的特定地址，该地址由桥接服务控制。该服务接收令牌，然后验证交易。验证后，交易在目标区块链上以相同数量完成。</strong></p><p><strong><img src="https://images.ctfassets.net/mjqoq33y05of/4sozFtvJ9dl2bgnUI1EyJW/cd8da19da7c3e2888bd5b2d9e26a3528/bridge-flow-diagram.jpg" alt="img"></strong></p><p><strong><a href="https://www.bnbchain.org/en/bridge">这就是像Binance Chain Bridge</a>和<a href="https://anyswap.exchange/#/router">Anyswap</a>这样流行的跨链桥的工作原理。像质押和收益农业这样的 DeFi 应用程序是跨链桥的流行用例。用户可以跟踪并转移到不同的链，这将使他们能够赚取更多的资金。</strong> </p><p><strong>跨链桥梁远非完美。在 Google 上快速搜索“跨链桥”将提供有关<a href="https://www.thedefiant.io/nomad-bridge-exploit">许多报告</a><a href="https://www.cryptotimes.io/ronin-bridge-hackers-transfer-625m-to-bitcoin-network/">的流行</a><a href="https://www.theverge.com/2022/2/3/22916111/wormhole-hack-github-error-325-million-theft-ethereum-solana">跨桥黑客攻击的结果。</a>与其他区块链互通性方法相比，跨链桥更容易受到攻击有几个原因：</strong> </p><p><strong>-集中化- 大多数网桥由中央服务控制，功能由联合或运营多重签名钱包的组执行。这会在过程中产生固定的故障点和一组固定的目标，供攻击者利用以消耗资金。</strong> </p><p><strong>-流动性- 要使跨链桥发挥作用，该服务必须在源链和目标链上都有可用资金。这些桥梁可以容纳大量资金，这使它们成为攻击者的有吸引力的目标。</strong> </p><p><strong>-复杂性- 跨链桥处理复杂的请求，还必须适应不同区块链的功能。这样，跨链桥每增加一条新的链来支持，桥处理的复杂度也随之增加。在复杂性增加的地方，攻击者可以瞄准的机会和区域也会增加。</strong> </p><h2 id="互通性解决方案——智能方式"><a href="#互通性解决方案——智能方式" class="headerlink" title="互通性解决方案——智能方式"></a><strong>互通性解决方案——智能方式</strong></h2><p><strong>互通性解决方案是一种网络，使您的应用程序能够移动任何资产，并执行与网络支持的任何链之间的合约调用或消息。这些网络充当互通层，为您的应用程序启用跨链通信。</strong> </p><p><strong>这些解决方案中的每一个都具有不同级别的去中心化和安全性。Axelar 是第一个完全支持与其连接的区块链相同级别的去中心化的公司——它本身就是一个区块链。作为由<a href="https://docs.tendermint.com/v0.34/">Tendermint 共识架构</a>支持的权益证明网络，Axelar 网络上的每个节点都运行多个连接链的软件。这些节点监控状态、验证交易并运行将交易从一条连接链路由到另一条的无许可协议。这种统一的架构为跨链交易提供了可扩展且安全的解决方案，并以最少的安全假设提供了区块链互通性。</strong></p><p><strong><img src="https://images.ctfassets.net/mjqoq33y05of/1m6quNFvcqa9JyGhonuVbC/f525612a5d8f2f1d46a5a53a50de3e65/axl-techstack__1_.jpeg" alt="img"></strong></p><p><strong>作为区块链，Axelar 还能够执行其他跨链服务无法复制的功能。例如，Axelar 网络可以生成一次性存款地址，去中心化项目可以使用这些地址来创建与中心化交易所相媲美的用户入口，以实现简单性和易用性。Axelar 网络还以编程方式处理到所有连接链的路由。这意味着，当一条新的链连接起来时，它立即获得了连接整个网络的好处，并且复合网络效应是瞬时的。</strong> </p><p><strong>作为开发人员，您可以使用<a href="https://docs.axelar.dev/dev/axelarjs-sdk/intro">Axelar SDK</a>和 API 在 Axelar 网络中任何受支持的链上调用合约。例如，这使您可以像调用原生链上的合约一样简单地从 Solana 调用 Ethereum 的 Compound Smart Contract。现在，您可以专注于在最适合您的项目的链上提供最佳用户体验，并让 Axelar 为您提供与其他区块链的安全连接层。</strong> </p><h2 id="Wrapping-up"><a href="#Wrapping-up" class="headerlink" title="Wrapping up"></a>Wrapping up</h2><p><strong>关于您的应用程序的决定应该带有一个明确的优先级列表。重要的是要考虑解决方案的安全性，评估它提供的功能，确定它是否可扩展，并检查它的去中心化方法。我们在这里讨论了一些传统的区块链互通性方法如何处理这些优先级，并概述了 Axelar 方法的不同之处。您现在拥有了自信地选择通向互通性道路的知识。</strong> </p><p><strong>准备好开始构建跨链应用了吗？查看我们的<a href="https://docs.axelar.dev/dev/guides/video-guides">视频演练</a>，向您展示如何构建、测试和部署到 Axlear 网络。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Axelar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Axelar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可组合的 USDC：多链世界中的无缝 UX（体验）</title>
      <link href="/2022/10/21/%E5%8F%AF%E7%BB%84%E5%90%88%E7%9A%84%20USDC%EF%BC%9A%E5%A4%9A%E9%93%BE%E4%B8%96%E7%95%8C%E4%B8%AD%E7%9A%84%E6%97%A0%E7%BC%9D%20UX%EF%BC%88%E4%BD%93%E9%AA%8C%EF%BC%89/"/>
      <url>/2022/10/21/%E5%8F%AF%E7%BB%84%E5%90%88%E7%9A%84%20USDC%EF%BC%9A%E5%A4%9A%E9%93%BE%E4%B8%96%E7%95%8C%E4%B8%AD%E7%9A%84%E6%97%A0%E7%BC%9D%20UX%EF%BC%88%E4%BD%93%E9%AA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="https://miro.medium.com/max/680/1*GQX3MKzXAsagtUWogvKH0A.jpeg" alt="img"></p><p>区块链生态系统是多链的。Avalanche、Cosmos、Ethereum、Polygon 和 Sui 正在成长并迎合不同的开发者群体。今天的开发人员了解如何在任何单个链上构建，并拥有一套工具和学习材料供他们使用。然而，在当今的多链生态系统中导航是复杂的，并且需要在应用程序的架构方式上进行范式转变。</p><p>Axelar 是一个去中心化且无需许可的跨链平台，提供安全的跨链通信和尖端的开发工具。将 Axelar 与 Circle 最近宣布的跨链传输协议 (CCTP) 相结合，我们计划解锁无缝的 Web3 用户体验，让数十亿用户可以使用区块链技术。</p><p><strong>简述</strong></p><ul><li>Circle 宣布了<a href="https://www.circle.com/en/pressroom/circle-enables-usdc-interoperability-for-developers-with-the-launch-of-cross-chain-transfer-protocol">跨链传输协议</a>，使 USDC 能够在本地跨链流动 — 消除了在受支持链上包装版本的需要。</li><li>Axelar 将通用消息传递添加到 Circle 的协议中。</li><li>Axelar 和 Circle 计划共同启用可组合的 USDC：开发人员组合一键式多链体验，将原生 USDC 和函数调用整合到任何连接链上的任何 dApp。</li></ul><h2 id="“现有的跨链格局为-Web3-的广泛采用设置了障碍。”"><a href="#“现有的跨链格局为-Web3-的广泛采用设置了障碍。”" class="headerlink" title="“现有的跨链格局为 Web3 的广泛采用设置了障碍。”"></a>“现有的跨链格局为 Web3 的广泛采用设置了障碍。”</h2><p>跨链 UX 的碎片化方式会造成低效的用户体验并带来不必要的成本和风险。要在网络之间移动，用户需要 (1) 导航到多个前端和桥接 UI，(2) 提交多个交易和 (3) 连接到多个钱包。从用户的角度来看，在 Solana 上持有的 USDC 与在 Ethereum 或 Avalanche 上持有的 USDC 是不同的。今天桥接 USDC 可能成本高昂且资本效率低下，因为它需要一些流动性提供者来促进交换并收取费用。现有桥接解决方案的安全问题可能会阻碍采用。最近的桥接黑客已经造成了一种观念，即安全的跨链通信是不可能的。</p><p><a href="https://medium.com/collab-currency/interoperability-and-market-segmentation-9cd098382414">这种市场细分</a>的成本是多少？<a href="https://medium.com/dragonfly-research/axelar-bridges-and-blockchain-globalization-11ef3bbce9f1">当开发人员拥有工具来构建与任何链上的本地资产（未包装的表示）交互的应用程序时，机会范围</a>如何扩大，用户只需单击一下？</p><h2 id="可组合的-USDC：安全无缝的跨链用户体验"><a href="#可组合的-USDC：安全无缝的跨链用户体验" class="headerlink" title="可组合的 USDC：安全无缝的跨链用户体验"></a>可组合的 USDC：安全无缝的跨链用户体验</h2><p>为了使开发人员能够在多链世界中创建无缝用户体验，Circle 和 Axelar 构建了强大的工具：</p><ul><li>跨链转移协议：在 Converge22 上，Circle 宣布计划推出一种无需许可的协议，该协议使用与商业 Circle 账户相同的跨链燃烧和铸造过程 — — 使用户能够跨链本地转移 USDC。</li><li>Axelar 的通用消息传递 (GMP)：大多数人都熟悉跨链桥，它只能传输资产的包装表示。GMP 不仅如此：Axelar 可以传输任何有效负载，允许开发人员构建真正的跨链应用程序，提供一键式用户体验 (UX)。</li><li>CCTP 和 GMP 一起允许开发人员通过原生跨链 USDC 传输以原子方式传递有效负载。这使得创建完全无缝和通用的跨链 dApp 成为可能，将 USDC 和用户带入每个受支持的生态系统。用户将能够使用 GMP 有效负载发出单个事务，并且在后端，应用程序负责桥接和用户在有效负载中指示的任何其他操作。</li></ul><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>通过组合 Axelar GMP 和 Circle 的 CCTP，用户可以获得以下好处：</p><ul><li><strong>可组合的USDC</strong>可以用作跨链的路由资产，消除碎片化。用户知道他们拥有 USDC，并且永远不必考虑他们持有 USDC 的链。</li><li><strong>一键跨链交易。</strong>Axelar 中继和<a href="https://docs.axelar.dev/dev/gas-services/intro">Gas 服务</a>允许用户一键跨应用执行跨链调用，只在源链上支付 Gas。</li><li><strong>增强的安全性：</strong> Axelar 是一个去中心化的网络，可以证明除了 Circle 的 CCTP 之外，USDC 在源链上被正确地烧毁，然后在目标链上执行请求。</li><li><strong>无滑点：</strong> USDC 转账在本地发生，无需流动资金池。用户只需支付gas费用。</li><li><strong>强大的开发者工具和精准的交易监控：</strong> <a href="https://docs.axelar.dev/dev/monitor-recover/monitoring">Axelar SDK</a>可用于追踪USDC跨链交易的状态、调试、中继。所有跨链活动都可以通过<a href="https://axelarscan.io/">axelarscan.io</a>和相关的 API 看到。</li></ul><h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><p>我们描述了三个用例来说明这种方法的强大功能：</p><ul><li><strong>无缝跨链交换：</strong>用户将能够跨不同链上的资产执行无缝跨链交换 [ETH for AVAX]。为了执行此类请求，可以将 ETH 交换为 USDC，该 USDC 被路由并交换为目标链上的 AVAX。目标链上的路由和执行完全从用户那里抽象出来，提供无缝的一键式体验。LP 从不承担任何过桥风险，因为他们在两条链上都持有原生 ETH、USDC 和 AVAX。<a href="https://www.youtube.com/watch?v=RyQkEcM1nKE">https://www.youtube.com/watch?v=RyQkEcM1nKE</a></li><li><strong>一键存款：</strong>在 dYdX 等永久交易所开仓，该交易所位于其自己的应用程序特定链上，可随时随地进行。在源链（例如 Avalanche）上，用户发出单笔交易，将 USDC 发送到 dYdX 链并代表用户开仓。为了平仓，用户稍后从 Avalanche 发出另一笔交易，该交易在后端被路由到 dYdX 链。用户无需更换钱包，甚至无需知道 dYdX 位于不同的链上。不会发生滑点。</li><li><strong>跨链 NFT：</strong> Solana 上的 USDC 持有者想要购买在以太坊 OpenSea 上列出的 NFT。用户从他们的 Phantom 钱包发出交易，NFT 在以太坊上的 OpenSea 上购买，然后交付回用户在 Solana 上的 Phantom 钱包。用户无需与与以太坊兼容的钱包（例如 MetaMask）交互，从而节省了时间和精力，现在可以在 Solana 应用程序中使用他们的 NFT。</li></ul><p>我们很高兴与 Circle 合作，以保护 Web3 并使其对下一个数百万用户普遍且易于访问。</p><p><strong>Axelar 的通用消息传递功能今天可用 -</strong><a href="https://docs.axelar.dev/dev/guides/example-usdc"><strong>让我们构建</strong></a></p><p>Circle 的跨链传输协议预计将于今年晚些时候在以太坊和 Avalanche 主网上推出。测试网可用性和文档即将推出。<a href="https://discord.com/invite/buildoncircle">在discord.com&#x2F;invite&#x2F;buildoncircle</a>加入对话</p>]]></content>
      
      
      <categories>
          
          <category> Axelar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Axelar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宣布由Axelar支持的Interop Summit</title>
      <link href="/2022/10/17/%E5%AE%A3%E5%B8%83%E7%94%B1Axelar%E6%94%AF%E6%8C%81%E7%9A%84Interop%20Summit/"/>
      <url>/2022/10/17/%E5%AE%A3%E5%B8%83%E7%94%B1Axelar%E6%94%AF%E6%8C%81%E7%9A%84Interop%20Summit/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>Interop Summit是区块链有史以来第一个通用聚会点，供构建者创建跨 Web3 的 dApp 的支持。</strong></p><p><strong>原文：<a href="https://axelar.network/blog/announcing-the-interop-summit-powered-by-axelar">https://axelar.network/blog/announcing-the-interop-summit-powered-by-axelar</a></strong></p><p><strong>翻译：FeiDan</strong></p></blockquote><p><img src="https://images.ctfassets.net/mjqoq33y05of/4gNgWePtTNroOktKrbPdkZ/df47f35951a232fdf8a62c03b7eb48c7/interop-summit-banner-2022Oct.jpg" alt="img"></p><p><strong>有一个范式的转变即将到来，改变了我们为Web3构建的方式。 我们不会再考虑 “Ethereum dApp “或 “Cosmos wallet.”。</strong></p><p><strong>我们不再主要考虑生态系统，而是主要考虑用户，提供任何所需的功能或连接，并欢迎任何用户资产或身份验证。我们也会考虑架构和基础设施，在最适合快速开发和安全、可扩展执行的位置构建和运行程序。</strong></p><p><strong>这种新的 Web3 开发范式并不容易实现。将会有新的选择需要做出，新的架构概念需要掌握。</strong></p><p><strong>这就是 Axelar 推出 Interop Summit的原因，作为这个新兴跨链未来的建设者聚集在一起并相互学习的地方。</strong></p><p><strong>Interop Summit是区块链有史以来第一个通用聚集点，供构建者创建跨 Web3 的 dApp 使用。为期 2.5 天的活动将汇集来自每个生态系统的最优秀人才，作为研讨会、小组讨论和私人 VIP 活动的演讲者和教育者。</strong></p><p><strong>Interop 峰会将于 2023 年 2 月 20 日至 22 日在佛罗里达州迈阿密海滩的枫丹白露度假村举行。</strong></p><p><strong>尽早在 <a href="https://interopsummit.com/home">https://interopsummit.com/home</a> 购买门票。</strong></p><p><strong><a href="http://eepurl.com/h_WwUH">注册电子邮件</a>以随时了解谁在会议上发言 - 或者，<a href="https://twitter.com/Interop_Summit">在 Twitter 上关注 Interop 峰会</a>。并寻找相关的教育材料，以帮助您加速 Web3 的互操作未来。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Axelar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Axelar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件</title>
      <link href="/2022/10/17/%E4%BA%8B%E4%BB%B6/"/>
      <url>/2022/10/17/%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p><code>Solidity</code>中的事件（<code>event</code>）是<code>EVM</code>上日志的抽象，它具有两个特点：</p><ul><li><strong>响应：应用程序（<a href="https://learnblockchain.cn/docs/ethers.js/api-contract.html#id18"><code>ether.js</code></a>）可以通过<code>RPC</code>接口订阅和监听这些事件，并在前端做响应。</strong></li><li><strong>经济：事件是<code>EVM</code>上比较经济的存储数据的方式，每个大概消耗2,000 <code>gas</code>；相比之下，链上存储一个新变量至少需要20,000 <code>gas</code>。</strong></li></ul><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p><strong>事件的声明由<code>event</code>关键字开头，然后跟事件名称，括号里面写好事件需要记录的变量类型和变量名。以<code>ERC20</code>代币合约的<code>Transfer</code>事件为例：</strong></p><ol><li><p><strong>我们可以看到，Transfer事件共记录了3个变量from，to和value，分别对应代币的转账地址，接收地址和转账数量。</strong></p></li><li><p><strong>每个indexed标记的变量可以理解为检索事件的索引“键”，在以太坊上单独作为一个topic进行存储和索引，程序可以轻松的筛选出特定转账地址和接收地址的转账事件。</strong></p></li><li><p><strong>事件的哈希以及这三个带indexed的变量在EVM日志中通常被存储为topic。其中topic[0]是此事件的keccak256哈希，topic[1]到topic[3]存储了带indexed变量的keccak256哈希。</strong></p></li><li><p><strong>每个事件最多有3个带indexed的变量。每个 indexed 变量的大小为固定的256比特。</strong></p></li><li><p><strong><code>value</code> 不带 <code>indexed</code> 关键字，会存储在事件的 <code>data</code> 部分中，可以理解为事件的“值”。</strong></p></li><li><p><strong><code>data</code> 部分的变量不能被直接检索，但可以存储任意大小的数据。因此一般 <code>data</code> 部分可以用来存储复杂的数据结构，例如数组和字符串等等，因为这些数据超过了256比特，即使存储在事件的 <code>topic</code> 部分中，也是以哈希的方式存储。</strong></p></li><li><p><strong>另外，<code>data</code> 部分的变量在存储上消耗的gas相比于 <code>topic</code> 更少。</strong></p></li></ol><pre><code class="solidity">event Transfer(address indexed from, address indexed to, uint256 value);</code></pre><p><img src="https://wtf.academy/assets/images/12-3-b08311699b4378c7b077f1cd966b51e2.jpg" alt="img"></p><p><strong>我们可以在函数里释放事件。在下面的例子中，每次用<code>_transfer()</code>函数进行转账操作的时候，都会释放<code>Transfer</code>事件，并记录相应的变量。</strong></p><pre><code class="solidity">// SPDX-License-Identifier: MIT//声明solidity版本 这行代码意思是源文件将不允许小于 0.8.4 版本或大于等于 0.9.0 版本的编译器编译pragma solidity ^0.8.4; contract HelloWeb3&#123;   mapping(address =&gt;uint256) public _balances;   event Transfer(address indexed from, address indexed to, uint256 value);     // 定义_transfer函数，执行转账逻辑    function _transfer(        address from,        address to,        uint256 amount    ) external &#123;        _balances[from] = 10000000; // 给转账地址一些初始代币        _balances[from] -=  amount; // from地址减去转账数量        _balances[to] += amount; // to地址加上转账数量        // 释放事件        emit Transfer(from, to, amount);    &#125;&#125;</code></pre><h3 id="Remix-演示"><a href="#Remix-演示" class="headerlink" title="Remix 演示"></a><strong>Remix 演示</strong></h3><p><strong>以 <code>Event.sol</code> 合约为例，编译部署。</strong></p><p><strong>然后调用 <code>_transfer</code> 函数。 <img src="https://wtf.academy/assets/images/12-1-21d3090d03ff4dbb241e5810f2177fe8.jpg" alt="img"></strong></p><p><strong>点击右侧的交易查看详情，可以看到日志的具体内容。 <img src="https://wtf.academy/assets/images/12-2-4faa09c9994dc41555b86c1f023b4c38.jpg" alt="img"></strong></p><h3 id="在etherscan上查询事件"><a href="#在etherscan上查询事件" class="headerlink" title="在etherscan上查询事件"></a><strong>在etherscan上查询事件</strong></h3><p><strong>我们尝试用<code>_transfer()</code>函数在<code>Rinkeby</code>测试网络上转账100代币，可以在<code>etherscan</code>上查询到相应的<code>tx</code>：<a href="https://rinkeby.etherscan.io/tx/0x8cf87215b23055896d93004112bbd8ab754f081b4491cb48c37592ca8f8a36c7">网址</a>。</strong></p><p><strong>点击<code>Logs</code>按钮，就能看到事件明细：</strong></p><p><strong><img src="https://images.mirror-media.xyz/publication-images/gx6_wDMYEl8_Gc_JkTIKn.png?height=980&width=1772" alt="Event明细"></strong></p><p><strong><code>Topics</code>里面有三个元素，<code>[0]</code>是这个事件的哈希，<code>[1]</code>和<code>[2]</code>是我们定义的两个<code>indexed</code>变量的信息，即转账的转出地址和接收地址。<code>Data</code>里面是剩下的不带<code>indexed</code>的变量，也就是转账数量。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造函数和修饰器</title>
      <link href="/2022/10/17/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E4%BF%AE%E9%A5%B0%E5%99%A8/"/>
      <url>/2022/10/17/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E4%BF%AE%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><strong>构造函数</strong></h2><p><strong>构造函数（<code>constructor</code>）是一种特殊的函数，每个合约可以定义一个，并在部署合约的时候自动运行一次。它可以用来初始化合约的一些参数，例如初始化合约的<code>owner</code>地址：</strong></p><pre><code class="solidity">   address owner; // 定义owner变量   // 构造函数   constructor() &#123;      owner = msg.sender; // 在部署合约的时候，将owner设置为部署者的地址   &#125;</code></pre><p><strong>构造函数在不同的solidity版本中的语法并不一致，在Solidity 0.4.22之前，构造函数不使用 <code>constructor</code> 而是使用与合约名同名的函数作为构造函数而使用，由于这种旧写法容易使开发者在书写时发生疏漏（例如合约名叫 <code>Parents</code>，构造函数名写成 <code>parents</code>），使得构造函数变成普通函数，引发漏洞，所以0.4.22版本及之后，采用了全新的 <code>constructor</code> 写法。</strong></p><p><strong>构造函数的旧写法代码示例：</strong></p><pre><code class="solidity">pragma solidity =0.4.21;contract Parents &#123;    // 与合约名Parents同名的函数就是构造函数    function Parents () public &#123;    &#125;&#125;</code></pre><h2 id="修饰器"><a href="#修饰器" class="headerlink" title="修饰器"></a>修饰器</h2><p><strong>修饰器（<code>modifier</code>）是<code>solidity</code>特有的语法，类似于面向对象编程中的<code>decorator</code>.</strong></p><p><strong>声明函数拥有的特性，并减少代码冗余。它就像钢铁侠的智能盔甲，穿上它的函数会带有某些特定的行为。<code>modifier</code>的主要使用场景是运行函数前的检查，例如地址，变量，余额等。</strong></p><pre><code class="solidity">   // 定义modifier   modifier onlyOwner &#123;      require(msg.sender == owner); // 检查调用者是否为owner地址      _; // 如果是的话，继续运行函数主体；否则报错并revert交易   &#125;</code></pre><pre><code class="solidity">    //代有onlyOwner修饰符的函数只能被owner地址调用，比如下面这个例子：   function changeOwner(address _newOwner) external onlyOwner&#123;      owner = _newOwner; // 只有owner地址运行这个函数，并改变owner   &#125;</code></pre><p>我们定义了一个<code>changeOwner</code>函数，运行他可以改变合约的<code>owner</code>，但是由于<code>onlyOwner</code>修饰符的存在，只有原先的<code>owner</code>可以调用，别人调用就会报错。这也是最常用的控制智能合约权限的方法。</p>]]></content>
      
      
      <categories>
          
          <category> Solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>控制流-循环</title>
      <link href="/2022/10/17/%E6%8E%A7%E5%88%B6%E6%B5%81-%E5%BE%AA%E7%8E%AF/"/>
      <url>/2022/10/17/%E6%8E%A7%E5%88%B6%E6%B5%81-%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p><code>**Solidity</code>的控制流与其他语言类似，主要包含以下几种：**</p><p><strong><code>if-else</code></strong></p><pre><code class="solidity">function ifElseTest(uint256 _number) public pure returns(bool)&#123;    if(_number == 0)&#123;    return(true);    &#125;else&#123;    return(false);    &#125;&#125;</code></pre><p><strong><code>for循环</code></strong></p><pre><code class="solidity">function forLoopTest() public pure returns(uint256)&#123;    uint sum = 0;    for(uint i = 0; i &lt; 10; i++)&#123;    sum += i;    &#125;    return(sum);&#125;</code></pre><p><strong><code>while循环</code></strong></p><pre><code class="solidity">function whileTest() public pure returns(uint256)&#123;    uint sum = 0;    uint i = 0;    while(i &lt; 10)&#123;    sum += i;    i++;    &#125;    return(sum);&#125;</code></pre><p><strong><code>do-while循环</code></strong></p><pre><code class="solidity">function doWhileTest() public pure returns(uint256)&#123;    uint sum = 0;    uint i = 0;    do&#123;    sum += i;    i++;    &#125;while(i &lt; 10);    return(sum);&#125;</code></pre><p><strong><code>三元运算符</code> 三元运算符是<code>solidity</code>中唯一一个接受三个操作数的运算符，规则<code>条件? 条件为真的表达式:条件为假的表达式</code>。 此运算符经常用作 if 语句的快捷方式。</strong></p><pre><code class="solidity">// 三元运算符 ternary/conditional operatorfunction ternaryTest(uint256 x, uint256 y) public pure returns(uint256)&#123;    // return the max of x and y    return x &gt;= y ? x: y; &#125;</code></pre><p><strong>另外还有<code>continue</code>（立即进入下一个循环）和<code>break</code>（跳出当前循环）关键字可以使用。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常数constant和immutable</title>
      <link href="/2022/10/17/%E5%B8%B8%E6%95%B0constant%E5%92%8Cimmutable/"/>
      <url>/2022/10/17/%E5%B8%B8%E6%95%B0constant%E5%92%8Cimmutable/</url>
      
        <content type="html"><![CDATA[<p><strong><code>constant</code>（常量）和<code>immutable</code>（不变量）</strong></p><p><strong>状态变量声明这个两个关键字之后，不能在合约后更改数值；并且还可以节省<code>gas</code>。只有数值变量可以声明<code>constant</code>和<code>immutable</code>；</strong></p><p><strong><code>string</code>和<code>bytes</code>可以声明为<code>constant</code>，但不能为<code>immutable</code>。</strong></p><h3 id="constant"><a href="#constant" class="headerlink" title="constant"></a>constant</h3><pre><code class="solidity">    // constant变量必须在声明的时候初始化，之后不能改变    uint256 constant CONSTANT_NUM = 10;    string constant CONSTANT_STRING = &quot;0xAA&quot;;    bytes constant CONSTANT_BYTES = &quot;WTF&quot;;    address constant CONSTANT_ADDRESS = 0x0000000000000000000000000000000000000000;</code></pre><h3 id="immutable"><a href="#immutable" class="headerlink" title="immutable"></a>immutable</h3><p><strong><code>immutable</code>变量可以在声明时或构造函数中初始化，因此更加灵活。</strong></p><pre><code class="solidity">// SPDX-License-Identifier: MIT//声明solidity版本 这行代码意思是源文件将不允许小于 0.8.4 版本或大于等于 0.9.0 版本的编译器编译pragma solidity ^0.8.4; contract HelloWeb3&#123;   // immutable变量可以在constructor里初始化，之后不能改变    uint256 public immutable IMMUTABLE_NUM = 9999999999;    address public immutable IMMUTABLE_ADDRESS;    uint256 public immutable IMMUTABLE_BLOCK;    uint256 public immutable IMMUTABLE_TEST;    // 利用constructor初始化immutable变量，因此可以利用    constructor()&#123;        IMMUTABLE_ADDRESS = address(this);        IMMUTABLE_BLOCK = block.number;        IMMUTABLE_TEST = test();    &#125;        function test() public pure returns(uint256)&#123;        uint256 what = 9;        return(what);    &#125;&#125;</code></pre><p><code>constant</code>变量初始化之后，尝试改变它的值，会编译不通过并抛出<code>TypeError: Cannot assign to a constant variable.</code>的错误。</p><p><img src="https://wtf.academy/assets/images/9-2-5b85f9969dff8fbeb78cac9f8d4089ce.png" alt="9-2.png"></p><p><code>immutable</code>变量初始化之后，尝试改变它的值，会编译不通过并抛出<code>TypeError: Immutable state variable already initialized.</code>的错误。</p><p><img src="data:image/png;base64,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" alt="9-3.png"></p>]]></content>
      
      
      <categories>
          
          <category> Solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量初始值</title>
      <link href="/2022/10/16/%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%80%BC/"/>
      <url>/2022/10/16/%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p><strong>在<code>solidity</code>中，声明但没赋值的变量都有它的初始值或默认值。这一讲，我们将介绍常用变量的初始值。</strong></p><h3 id="值类型初始值"><a href="#值类型初始值" class="headerlink" title="值类型初始值"></a>值类型初始值</h3><ul><li><p><code>boolean</code>: <code>false</code></p></li><li><p><code>string</code>: <code>&quot;&quot;</code></p></li><li><p><code>int</code>: <code>0</code></p></li><li><p><code>uint</code>: <code>0</code></p></li><li><p><code>enum</code>: 枚举中的第一个元素</p></li><li><p><code>address</code>: <code>0x0000000000000000000000000000000000000000</code> (或 <code>address(0)</code>)</p></li><li><pre><code>function</code></pre><ul><li><code>internal</code>: 空白方程</li><li><code>external</code>: 空白方程</li></ul></li></ul><p>可以用<code>public</code>变量的<code>getter</code>函数验证上面写的初始值是否正确：</p><pre><code class="solidity">    bytes1 public _bytes; //0x00    bool public _bool; // false    string public _string; // &quot;&quot;    int public _int; // 0    uint public _uint; // 0    address public _address; // 0x0000000000000000000000000000000000000000    enum ActionSet &#123; Buy, Hold, Sell&#125;    ActionSet public _enum; // 第一个元素 0    function fi() internal&#123;&#125; // internal空白方程     function fe() external&#123;&#125; // external空白方程 </code></pre><h3 id="引用类型初始值"><a href="#引用类型初始值" class="headerlink" title="引用类型初始值"></a>引用类型初始值</h3><ul><li><strong>映射<code>mapping</code>: 所有元素都为其默认值的<code>mapping</code></strong></li><li><strong>结构体<code>struct</code>: 所有成员设为其默认值的结构体</strong></li><li><strong>数组<code>array</code></strong><ul><li><strong>动态数组: <code>[]</code></strong></li><li><strong>静态数组（定长）: 所有成员设为其默认值的静态数组</strong></li></ul></li></ul><p><strong>可以用<code>public</code>变量的<code>getter</code>函数验证上面写的初始值是否正确：</strong></p><pre><code class="solidity">// SPDX-License-Identifier: MIT//声明solidity版本 这行代码意思是源文件将不允许小于 0.8.4 版本或大于等于 0.9.0 版本的编译器编译pragma solidity ^0.8.4; contract HelloWeb3&#123;    // Reference Types    uint[8] public _staticArray; // 所有成员设为其默认值的静态数组[0,0,0,0,0,0,0,0]    uint[] public _dynamicArray; // `[]`    mapping(uint =&gt; address) public _mapping; // 所有元素都为其默认值的mapping    // 所有成员设为其默认值的结构体 0, 0    struct Student&#123;        uint256 id;        uint256 score;     &#125;    Student public student;&#125;</code></pre><h3 id="delete操作符"><a href="#delete操作符" class="headerlink" title="delete操作符"></a><code>delete</code>操作符</h3><p><code>delete a</code>会让变量<code>a</code>的值变为初始值。</p><pre><code class="solidity">    // delete操作符    bool public _bool2 = true;     function d() external &#123;        delete _bool2; // delete 会让_bool2变为默认值，false    &#125;</code></pre><h2 id="在remix上验证"><a href="#在remix上验证" class="headerlink" title="在remix上验证"></a>在remix上验证</h2><ul><li>部署合约查看值类型、引用类型的初始值 <img src="https://wtf.academy/assets/images/8-1-bf8a5eafba9f2a6be29c8a116a5465bc.png" alt="img"></li><li>值类型、引用类型delete操作后的默认值 <img src="https://wtf.academy/assets/images/8-2-968b7c57cb793dc524a5665dfae26624.png" alt="img"></li></ul>]]></content>
      
      
      <categories>
          
          <category> Solidity </category>
          
          <category> 变量 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>映射类型</title>
      <link href="/2022/10/16/%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/10/16/%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="映射Mapping"><a href="#映射Mapping" class="headerlink" title="映射Mapping"></a>映射Mapping</h2><p><strong>人们可以通过键（<code>Key</code>）来查询对应的值（<code>Value</code>）</strong></p><p><strong>声明映射的格式为<code>mapping(_KeyType =&gt; _ValueType)</code>，其中<code>_KeyType</code>和<code>_ValueType</code>分别是<code>Key</code>和<code>Value</code>的变量类型。例子：</strong></p><pre><code class="solidity"> mapping(uint =&gt; address) public idToAddress; // id映射到地址 mapping(address =&gt; address) public swapPair; // 币对的映射，地址到地址</code></pre><h2 id="映射的规则"><a href="#映射的规则" class="headerlink" title="映射的规则"></a>映射的规则</h2><ul><li><p><strong>映射的<code>_KeyType</code>只能选择<code>solidity</code>默认的类型，比如<code>uint</code>，<code>address</code>等，不能用自定义的结构体<code>struct</code>。</strong></p></li><li><p><strong>映射的存储位置必须是<code>storage</code>，因此可以用于合约的状态变量，函数中的<code>storage</code>变量，和library函数的参数（见<a href="https://github.com/ethereum/solidity/issues/4635">例子</a>）。不能用于<code>public</code>函数的参数或返回结果中，因为<code>mapping</code>记录的是一种关系 (key - value pair)。</strong></p></li><li><p><strong>如果映射声明为<code>public</code>，那么<code>solidity</code>会自动给你创建一个<code>getter</code>函数，可以通过<code>Key</code>来查询对应的<code>Value</code>。</strong></p></li><li><p><strong>给映射新增的键值对的语法为<code>_Var[_Key] = _Value</code>，其中<code>_Var</code>是映射变量名，<code>_Key</code>和<code>_Value</code>对应新增的键值对。例子：</strong></p></li></ul><pre><code class="solidity">// SPDX-License-Identifier: MIT//声明solidity版本 这行代码意思是源文件将不允许小于 0.8.4 版本或大于等于 0.9.0 版本的编译器编译pragma solidity ^0.8.4; contract HelloWeb3&#123;    mapping(uint =&gt; address) public idToAddress; // id映射到地址        function writeMap (uint _Key, address _Value) public&#123;        idToAddress[_Key] = _Value;    &#125;    &#125;</code></pre><h2 id="映射的原理"><a href="#映射的原理" class="headerlink" title="映射的原理"></a>映射的原理</h2><ul><li><strong>原理1: 映射不储存任何键（<code>Key</code>）的资讯，也没有length的资讯。</strong></li><li><strong>原理2: 映射使用<code>keccak256(key)</code>当成offset存取value。</strong></li><li><strong>原理3: 因为Ethereum会定义所有未使用的空间为0，所以未赋值（<code>Value</code>）的键（<code>Key</code>）初始值都是0。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Solidity </category>
          
          <category> 变量 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用类型</title>
      <link href="/2022/10/16/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/10/16/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="数组-array"><a href="#数组-array" class="headerlink" title="数组 array"></a><strong>数组 array</strong></h2><p><strong>数组（<code>Array</code>）是<code>solidity</code>常用的一种变量类型，用来存储一组数据（整数，字节，地址等等）。</strong></p><p><strong>固定长度数组：在声明时指定数组的长度。用<code>T[k]</code>的格式声明，其中<code>T</code>是元素的类型，<code>k</code>是长度，例如：</strong></p><pre><code class="solidity">    // 固定长度 Array    uint[8] array1;    bytes1[5] array2;    address[100] array3;</code></pre><p><strong>可变长度数组（动态数组）：在声明时不指定数组的长度。用<code>T[]</code>的格式声明，其中<code>T</code>是元素的类型，例如（<code>bytes</code>比较特殊，是数组，但是不用加<code>[]</code>）：</strong></p><pre><code class="solidity">    uint[] array4;    bytes1[] array5;    address[] array6;    bytes array7;</code></pre><h3 id="创建数组的规则"><a href="#创建数组的规则" class="headerlink" title="创建数组的规则"></a>创建数组的规则</h3><p><strong>在solidity里，创建数组有一些规则：</strong></p><p><strong>对于<code>memory</code>修饰的<code>动态数组</code>，可以用<code>new</code>操作符来创建，但是必须声明长度，并且声明后长度不能改变。例子：</strong></p><pre><code class="solidity">    // memory动态数组    uint[] memory array8 = new uint[](5);    bytes memory array9 = new bytes(9);</code></pre><p><strong>如果创建的是动态数组，你需要一个一个元素的赋值。</strong></p><pre><code class="solidity">    uint[] memory x = new uint[](3);    x[0] = 1;    x[1] = 3;    x[2] = 4;</code></pre><h3 id="数组成员"><a href="#数组成员" class="headerlink" title="数组成员"></a>数组成员</h3><ul><li><strong><code>length</code>: 数组有一个包含元素数量的<code>length</code>成员，<code>memory</code>数组的长度在创建后是固定的。</strong></li><li><strong><code>push()</code>: <code>动态数组</code>和<code>bytes</code>拥有<code>push()</code>成员，可以在数组最后添加一个<code>0</code>元素。</strong></li><li><strong><code>push(x)</code>: <code>动态数组</code>和<code>bytes</code>拥有<code>push(x)</code>成员，可以在数组最后添加一个<code>x</code>元素。</strong></li><li><strong><code>pop()</code>: <code>动态数组</code>和<code>bytes</code>拥有<code>pop()</code>成员，可以移除数组最后一个元素。</strong></li></ul><h2 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体 struct"></a>结构体 struct</h2><p><code>**Solidity</code>支持通过构造结构体的形式定义新的类型。创建结构体的方法：**</p><pre><code class="solidity">    // 结构体    struct Student&#123;        uint256 id;        uint256 score;     &#125;</code></pre><pre><code class="solidity">    Student student; // 初始一个student结构体</code></pre><p><strong>给结构体赋值的两种方法：</strong></p><pre><code class="solidity">    //  给结构体赋值    // 方法1:在函数中创建一个storage的struct引用    function initStudent1() external&#123;        Student storage _student = student; // assign a copy of student        _student.id = 11;        _student.score = 100;    &#125;</code></pre><pre><code class="solidity">   // 方法2:直接引用状态变量的struct    function initStudent2() external&#123;        student.id = 1;        student.score = 80;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solidity </category>
          
          <category> 变量 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量数据储存和作用域</title>
      <link href="/2022/10/16/%E5%8F%98%E9%87%8F%E6%95%B0%E6%8D%AE%E5%82%A8%E5%AD%98%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2022/10/16/%E5%8F%98%E9%87%8F%E6%95%B0%E6%8D%AE%E5%82%A8%E5%AD%98%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="数据位置"><a href="#数据位置" class="headerlink" title="数据位置"></a>数据位置</h2><p><strong>solidity数据存储位置有三类：<code>storage</code>，<code>memory</code>和<code>calldata</code>。</strong></p><p><strong>不同存储位置的<code>gas</code>成本不同。</strong></p><p><strong><code>storage</code>类型的数据存在链上，类似计算机的硬盘，消耗<code>gas</code>多；<code>memory</code>和<code>calldata</code>类型的临时存在内存里，消耗<code>gas</code>少。大致用法：</strong></p><ol><li><strong><code>storage</code>：合约里的状态变量默认都是<code>storage</code>，存储在链上。</strong></li><li><strong><code>memory</code>：函数里的参数和临时变量一般用<code>memory</code>，存储在内存中，不上链。</strong></li><li><strong><code>calldata</code>：和<code>memory</code>类似，存储在内存中，不上链。与<code>memory</code>的不同点在于<code>calldata</code>变量不能修改（<code>immutable</code>），一般用于函数的参数。例子：</strong></li></ol><pre><code class="solidity">// SPDX-License-Identifier: MIT//声明solidity版本 这行代码意思是源文件将不允许小于 0.8.4 版本或大于等于 0.9.0 版本的编译器编译pragma solidity ^0.8.4; contract HelloWeb3&#123;            function fCalldata(uint[] calldata _x) public pure returns(uint[] calldata)&#123;        //参数为calldata数组，不能被修改        // _x[0] = 0 //这样修改会报错        return(_x);    &#125;    &#125;</code></pre><p><img src="https://wtf.academy/assets/images/5-1-9d00a21842c77b3911aaf419f67ad691.png" alt="5-1.png"></p><h3 id="数据位置和赋值规则"><a href="#数据位置和赋值规则" class="headerlink" title="数据位置和赋值规则"></a>数据位置和赋值规则</h3><p><strong>在不同存储类型相互赋值时候，有时会产生独立的副本（修改新变量不会影响原变量），有时会产生引用（修改新变量会影响原变量）。规则如下：</strong></p><ol><li><strong><code>storage</code>（合约的状态变量）赋值给本地<code>storage</code>（函数里的）时候，会创建引用，改变新变量会影响原变量。例子：</strong></li></ol><pre><code class="solidity">// SPDX-License-Identifier: MIT//声明solidity版本 这行代码意思是源文件将不允许小于 0.8.4 版本或大于等于 0.9.0 版本的编译器编译pragma solidity ^0.8.4; contract HelloWeb3&#123;    uint[] x = [1,2,3]; // 状态变量：数组 x    function fStorage() public&#123;        //声明一个storage的变量 xStorage，指向x。修改xStorage也会影响x        uint[] storage xStorage = x;        xStorage[0] = 100;    &#125;&#125;</code></pre><p><img src="https://wtf.academy/assets/images/5-2-91bae5b0b86b0e55210cac541a6edee5.png" alt="5-2.png"></p><ol start="2"><li><p><strong><code>storage</code>赋值给<code>memory</code>，会创建独立的复本，修改其中一个不会影响另一个；</strong></p><pre><code class="solidity">// SPDX-License-Identifier: MIT//声明solidity版本 这行代码意思是源文件将不允许小于 0.8.4 版本或大于等于 0.9.0 版本的编译器编译pragma solidity ^0.8.4; contract HelloWeb3&#123;            uint[] x = [1,2,3]; // 状态变量：数组 x        function fMemory() public view&#123;        //声明一个Memory的变量xMemory，复制x。修改xMemory不会影响x        uint[] memory xMemory = x;        xMemory[0] = 100;        xMemory[1] = 200;        uint[] memory xMemory2 = x;        xMemory2[0] = 300;    &#125;&#125;</code></pre></li></ol><p><strong><img src="https://wtf.academy/assets/images/5-3-979f3cbffbbe20ff5df5c143384610e4.png" alt="5-3.png"></strong></p><ol start="3"><li><strong><code>memory</code>赋值给<code>memory</code>，会创建引用，改变新变量会影响原变量。</strong></li><li><strong>其他情况，变量赋值给<code>storage</code>，会创建独立的复本，修改其中一个不会影响另一个。</strong></li></ol><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p><strong><code>Solidity</code>中变量按作用域划分有三种，分别是状态变量（state variable），局部变量（local variable）和全局变量(global variable)</strong></p><h3 id="1-状态变量"><a href="#1-状态变量" class="headerlink" title="1. 状态变量"></a><strong>1. 状态变量</strong></h3><p><strong>状态变量是数据存储在链上的变量，所有合约内函数都可以访问 ，<code>gas</code>消耗高。状态变量在合约内、函数外声明：</strong></p><pre><code class="solidity">contract Variables &#123;    uint public x = 1;    uint public y;    string public z;</code></pre><p><strong>我们可以在函数里更改状态变量的值：</strong></p><pre><code class="solidity">    function foo() external&#123;        // 可以在函数里更改状态变量的值        x = 5;        y = 2;        z = &quot;0xAA&quot;;    &#125;</code></pre><h3 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="2. 局部变量"></a><strong>2. 局部变量</strong></h3><p><strong>局部变量是仅在函数执行过程中有效的变量，函数退出后，变量无效。局部变量的数据存储在内存里，不上链，<code>gas</code>低。局部变量在函数内声明：</strong></p><pre><code class="solidity">    function bar() external pure returns(uint)&#123;        uint xx = 1;        uint yy = 3;        uint zz = xx + yy;        return(zz);    &#125;</code></pre><h3 id="3-全局变量"><a href="#3-全局变量" class="headerlink" title="3. 全局变量"></a><strong>3. 全局变量</strong></h3><p><strong>全局变量是全局范围工作的变量，都是<code>solidity</code>预留关键字。他们可以在函数内不声明直接使用：</strong></p><pre><code class="solidity">    function global() external view returns(address, uint, bytes memory)&#123;        address sender = msg.sender;        uint blockNum = block.number;        bytes memory data = msg.data;        return(sender, blockNum, data);    &#125;</code></pre><p><strong>在上面例子里，我们使用了3个常用的全局变量：<code>msg.sender</code>, <code>block.number</code>和<code>msg.data</code>，他们分别代表请求发起地址，当前区块高度，和请求数据。下面是一些常用的全局变量，更完整的列表请看这个<a href="https://learnblockchain.cn/docs/solidity/units-and-global-variables.html#special-variables-and-functions">链接</a>：</strong></p><ul><li><strong><code>blockhash(uint blockNumber)</code>: (<code>bytes32</code>)给定区块的哈希值 – 只适用于256最近区块, 不包含当前区块。</strong></li><li><strong><code>block.coinbase</code>: (<code>address payable</code>) 当前区块矿工的地址</strong></li><li><strong><code>block.gaslimit</code>: (<code>uint</code>) 当前区块的gaslimit</strong></li><li><strong><code>block.number</code>: (<code>uint</code>) 当前区块的number</strong></li><li><strong><code>block.timestamp</code>: (<code>uint</code>) 当前区块的时间戳，为unix纪元以来的秒</strong></li><li><strong><code>gasleft()</code>: (<code>uint256</code>) 剩余 gas</strong></li><li><strong><code>msg.data</code>: (<code>bytes calldata</code>) 完整call data</strong></li><li><strong><code>msg.sender</code>: (<code>address payable</code>) 消息发送者 (当前 caller)</strong></li><li><strong><code>msg.sig</code>: (<code>bytes4</code>) calldata的前四个字节 (function identifier)</strong></li><li><strong><code>msg.value</code>: (<code>uint</code>) 当前交易发送的<code>wei</code>值</strong></li></ul><p><strong>Example: <img src="https://wtf.academy/assets/images/5-4-5ee425310e1666a20575f2a8330c55cb.png" alt="5-4.png"></strong></p>]]></content>
      
      
      <categories>
          
          <category> Solidity </category>
          
          <category> 变量 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数输出</title>
      <link href="/2022/10/16/%E5%87%BD%E6%95%B0%E8%BE%93%E5%87%BA/"/>
      <url>/2022/10/16/%E5%87%BD%E6%95%B0%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="返回值-return和returns"><a href="#返回值-return和returns" class="headerlink" title="返回值 return和returns"></a><strong>返回值 return和returns</strong></h2><p><strong><code>Solidity</code>有两个关键字与函数输出相关：<code>return</code>和<code>returns</code>，他们的区别在于：</strong></p><ul><li><p><strong><code>returns</code>加在函数名后面，用于声明返回的变量类型及变量名；</strong></p></li><li><p><strong><code>return</code>用于函数主体中，返回指定的变量。</strong></p></li></ul><pre><code class="solidity">// SPDX-License-Identifier: MIT//声明solidity版本 这行代码意思是源文件将不允许小于 0.8.4 版本或大于等于 0.9.0 版本的编译器编译pragma solidity ^0.8.4; contract HelloWeb3&#123;    //    function returnMultiple() public pure returns(uint256, bool, uint256[3] memory)&#123;            return(1, true, [uint256(1),2,5]);        &#125;    // 命名式返回    function returnNamed() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array)&#123;        _number = 2;        _bool = false;         _array = [uint256(3),2,1];    &#125;            // 命名式返回，依然支持return    function returnNamed2() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array)&#123;        return(1, true, [uint256(1),2,5]);    &#125;    &#125;</code></pre><h2 id="解构式赋值"><a href="#解构式赋值" class="headerlink" title="解构式赋值"></a>解构式赋值</h2><p><strong><code>solidity</code>使用解构式赋值的规则，支持读取函数的全部或部分返回值。</strong></p><p><strong>读取所有返回值：声明变量，并且将要赋值的变量用<code>,</code>隔开，按顺序排列。</strong></p><pre><code class="solidity">// SPDX-License-Identifier: MIT//声明solidity版本 这行代码意思是源文件将不允许小于 0.8.4 版本或大于等于 0.9.0 版本的编译器编译pragma solidity ^0.8.4; contract HelloWeb3&#123;    // 命名式返回    function returnNamed() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array)&#123;        _number = 2;        _bool = false;         _array = [uint256(3),2,1];    &#125;            // 命名式返回，依然支持return    function returnNamed2() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array)&#123;        return(1, true, [uint256(1),2,5]);    &#125;    function readNamed() public pure&#123;        uint256 _number;        bool _bool;        uint256[3] memory _array;        (_number, _bool, _array) = returnNamed();        //或者只读取一个值  (, _bool, ) = returnNamed();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solidity </category>
          
          <category> 函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数类型</title>
      <link href="/2022/10/15/%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/10/15/%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="solidity中函数的形式："><a href="#solidity中函数的形式：" class="headerlink" title="solidity中函数的形式："></a><strong>solidity中函数的形式：</strong></h3><pre><code class="solidity">    function &lt;function name&gt; (&lt;parameter types&gt;) &#123;internal|external|public|private&#125; [pure|view|payable] [returns (&lt;return types&gt;)]</code></pre><ol><li><p><strong><code>function</code>：声明函数时的固定用法，想写函数，就要以function关键字开头。</strong></p></li><li><p><strong><code>&lt;function name&gt;</code>：函数名</strong></p></li><li><p><strong><code>(&lt;parameter types&gt;)</code>：函数的参数，也就是要输入到函数的变量类型和名字。</strong></p></li><li><p><strong><code>&#123;internal|external|public|private&#125;</code>：函数可见性说明符，一共4种。没标明函数类型的，默认<code>internal</code>。</strong></p><ul><li><p><strong><code>public</code>: 内部外部均可见。(也可用于修饰状态变量，public变量会自动生成 <code>getter</code>函数，用于查询数值).</strong></p></li><li><p><strong><code>private</code>: 只能从本合约内部访问，继承的合约也不能用（也可用于修饰状态变量）。</strong></p></li><li><p><strong><code>external</code>: 只能从合约外部访问（但是可以用<code>this.f()</code>来调用，<code>f</code>是函数名）</strong></p></li><li><p><strong><code>internal</code>: 只能从合约内部访问，继承的合约可以用（也可用于修饰状态变量）。</strong></p></li></ul></li><li><p><strong><code>[pure|view|payable]</code>：决定函数权限&#x2F;功能的关键字。<code>payable</code>（可支付的）很好理解，带着它的函数，运行的时候可以给合约转入<code>ETH</code>。<code>pure</code>和<code>view</code>的介绍见下一节。</strong></p></li><li><p><strong><code>[returns ()]</code>：函数返回的变量类型和名称。</strong></p></li></ol><h3 id="到底什么是Pure和View？"><a href="#到底什么是Pure和View？" class="headerlink" title="到底什么是Pure和View？"></a>到底什么是<code>Pure</code>和<code>View</code>？</h3><p><strong><code>pure</code>跟<code>view</code>关键字的函数是不改&#x2F;写链上状态的，因此用户直接调用他们是不需要付gas的（合约中非<code>pure</code>&#x2F;<code>view</code>函数调用它们则会改写链上状态，需要付gas）。</strong></p><ol><li><p><strong>包含<code>pure</code>关键字的函数，不能读取也不能写入存储在链上的状态变量。</strong></p></li><li><p><strong>包含<code>view</code>关键字的函数，能读取但也不能写入状态变量。</strong></p></li><li><p><strong>不写<code>pure</code>也不写<code>view</code>，函数既可以读取也可以写入状态变量。</strong></p></li></ol><p><strong>在以太坊中，以下语句被视为修改链上状态：</strong></p><blockquote><p><strong>写入状态变量。</strong></p><p><strong>释放事件。</strong></p><p><strong>创建其他合同。</strong></p><p><strong>使用selfdestruct.</strong></p><p><strong>通过调用发送以太币。</strong></p><p><strong>调用任何未标记view或pure的函数。</strong></p><p><strong>使用低级调用（low-level calls）。</strong></p><p><strong>使用包含某些操作码的内联汇编。</strong></p></blockquote><p><strong>以下被认为是从状态中读取：</strong></p><blockquote><ol><li><strong>读取状态变量。</strong></li><li><strong>访问 <code>this.balance</code> 或者 <code>&lt;address&gt;.balance</code>。</strong></li><li><strong>访问 <code>block</code>，<code>tx</code>， <code>msg</code> 中任意成员 （除 <code>msg.sig</code> 和 <code>msg.data</code> 之外）。</strong></li><li><strong>调用任何未标记为 <code>pure</code> 的函数。</strong></li><li><strong>使用包含某些操作码的内联汇编。</strong></li></ol></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="1-pure-v-s-view"><a href="#1-pure-v-s-view" class="headerlink" title="1. pure v.s  view"></a>1. pure v.s  view</h3><pre><code class="solidity">// SPDX-License-Identifier: MIT//声明solidity版本 这行代码意思是源文件将不允许小于 0.8.4 版本或大于等于 0.9.0 版本的编译器编译pragma solidity ^0.8.4; contract HelloWeb3&#123;        uint256 public number = 5;        //定义add函数 external是可以从合约外部调用此函数     function add() external&#123;        number = number + 1;    &#125;    //pure 不能读取也不能写入存储在链上的状态变量number    //那pure函数能做些什么？举个例子，你可以给函数传递一个参数 _number，然后让他返回 _number+1。    function addPure(uint256 _number) external pure returns(uint256 new_number)&#123;        new_number = _number+1;    &#125;    //view 能读取，但不能够改写状态变量number    //可以稍微改写下方程，让他不改写number，而是返回一个新的变量。    function addView() external view returns(uint256 new_number) &#123;        new_number = number + 1;    &#125;&#125;</code></pre><h3 id="2-internal-v-s-external"><a href="#2-internal-v-s-external" class="headerlink" title="2. internal v.s. external"></a>2. internal v.s. external</h3><pre><code class="solidity">// SPDX-License-Identifier: MIT//声明solidity版本 这行代码意思是源文件将不允许小于 0.8.4 版本或大于等于 0.9.0 版本的编译器编译pragma solidity ^0.8.4; contract Web3&#123;    uint256 public number = 5;     // internal: 内部    function minus() internal &#123;        number = number - 1;    &#125;    // 合约内的函数可以调用内部函数    function minusCall() external &#123;        minus();    &#125;&#125;</code></pre><h3 id="3-payable"><a href="#3-payable" class="headerlink" title="3. payable"></a>3. payable</h3><pre><code class="solidity">// SPDX-License-Identifier: MIT//声明solidity版本 这行代码意思是源文件将不允许小于 0.8.4 版本或大于等于 0.9.0 版本的编译器编译pragma solidity ^0.8.4; contract HelloWeb3&#123;    // payable: 递钱，能给合约支付eth的函数    function minusPayable() external payable returns(uint256 balance) &#123;        balance = address(this).balance;    &#125;&#125;</code></pre><p><strong>this关键字可以让我们引用合约地址</strong></p><p><img src="https://images.mirror-media.xyz/publication-images/ETDPN8myq7jFfAL8CUAFt.png?height=148&width=588" alt="img"></p><p><strong>我们可以在返回的信息中看到，合约的余额是1 ETH。</strong></p><p><img src="https://images.mirror-media.xyz/publication-images/nGZ2pz0MvzgXuKrENJPYf.png?height=128&width=1130" alt="img"></p><p><strong>Example:</strong> <img src="https://wtf.academy/assets/images/3-2-e1be980c21311dc80f6233dac763fd89.png" alt="3-2.png"></p>]]></content>
      
      
      <categories>
          
          <category> Solidity </category>
          
          <category> 函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块化执行案例（第一部分）</title>
      <link href="/2022/10/15/%E6%A8%A1%E5%9D%97%E5%8C%96%E6%89%A7%E8%A1%8C%E6%A1%88%E4%BE%8B%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89/"/>
      <url>/2022/10/15/%E6%A8%A1%E5%9D%97%E5%8C%96%E6%89%A7%E8%A1%8C%E6%A1%88%E4%BE%8B%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>模块化执行层（modular execution layers）如何通过将计算与验证解耦来实现可扩展性。</strong></p></blockquote><blockquote><p><strong>原文：<a href="https://fuel-labs.ghost.io/the-case-for-modular-execution-part-1/">https://fuel-labs.ghost.io/the-case-for-modular-execution-part-1/</a></strong></p><p><strong>翻译：FeiDan</strong></p></blockquote><p><img src="https://fuel-labs.ghost.io/content/images/size/w2000/2022/10/the-case-for-modular-execution-part-1.png" alt="The Case for Modular Execution (Part 1)"></p><h2 id="（模块化执行的案例）The-Case-for-Modular-Execution"><a href="#（模块化执行的案例）The-Case-for-Modular-Execution" class="headerlink" title="（模块化执行的案例）The Case for Modular Execution"></a>（模块化执行的案例）The Case for Modular Execution</h2><p><strong>为了实现真正的可扩展性，区块链空间正越来越多地向模块化架构发展。即使是像以太坊这样以前完全单体的链，也正在<a href="https://ethereum.org/en/upgrades/sharding/">转向</a>模块化设计，以克服单体区块链设计带来的挑战。</strong></p><p><strong><a href="https://fuel-labs.ghost.io/beyond-monolithic-the-modular-blockchain-paradigm/">模块化区块链栈</a>的核心组件之一是执行层。<a href="https://www.fuel.network/">Fuel</a>正在为模块化区块链栈构建最快的执行层。</strong></p><p><img src="https://fuel-labs.ghost.io/content/images/2022/10/image-13.png" alt="img"></p><p><strong>什么是模块化执行层？它们又将如何实现更多的可扩展区块链系统？</strong></p><p><strong>与单体执行层相比较，模块化执行层提供了两个核心优势：</strong></p><ol><li><p><strong>单片链将计算和验证耦合在同一层，导致安全性低于标准且可扩展性有限。模块化执行层通过解耦计算和验证来避免这种情况，从而在规模上提供更强大的安全保证。</strong></p></li><li><p><strong>当涉及到它们可以支持的计算速度和多样性时，单片链被锁定在低效的技术中。另一方面，模块化执行层可以专门设计用于优化高效计算。</strong></p></li></ol><p><strong>这篇文章详细阐述了第一个核心优势，第二个核心优势将在即将发布的第 2 部分中进行探讨。</strong></p><h2 id="单片区块链基础知识：计算和验证"><a href="#单片区块链基础知识：计算和验证" class="headerlink" title="单片区块链基础知识：计算和验证"></a>单片区块链基础知识：计算和验证</h2><p><strong>要了解来自模块化执行层 (MEL) 的创新，首先我们需要了解单片区块链如何处理计算和验证。</strong></p><p><strong>区块链依赖于一个实体网络，这些实体执行交易并将它们捆绑在一起形成一个区块——这些实体被称为<em>区块生产者</em>。如果没有制衡，恶意区块生产者可能会在区块中包含无效交易（例如，将代币铸造到他们自己的地址）。为了防止这种情况，区块链依赖于其他节点的网络来确定一个块的有效性，然后再将其添加到他们的链版本中。</strong></p><p><strong>这导致了区块链运行所需的两个核心功能：</strong></p><ul><li><strong>块生产（即计算） - 执行交易并应用单独的状态转换来构建块。</strong></li><li><strong>块验证（即验证） - 确认状态转换是有效的。</strong></li><li></li></ul><h3 id="单片链的计算和验证"><a href="#单片链的计算和验证" class="headerlink" title="单片链的计算和验证"></a><strong>单片链的计算和验证</strong></h3><p><em><strong>注意：为了便于理解，本节简要说明了块生产和验证如何在单片区块链上工作。实际上，该过程更复杂，并且可能因特定链的设计而异。然而，许多相同的核心原则也适用。</strong></em></p><p><strong>在大多数单片区块链设计中，计算和验证由相同的实体 - 验证器（即完整节点）执行。当用户发送交易时，验证者将执行交易，然后将相应的状态转换包含在块中。一旦创建并传播了一个块，其他完整节点就会下载该块并重新执行该块中的事务以确认它是有效的。如果该块是有效的，假设他们是诚实的，那么全节点将该块附加到他们的链版本上，从而证明它的有效性。</strong></p><p><strong>有时，应用程序或用户需要访问区块链的状态，但又不想招致运行全节点和独立验证所有事务的高资源需求。为此，他们可以运行<a href="https://www.parity.io/blog/what-is-a-light-client/">轻客户端</a>，假设全节点提供的块仅包含有效交易。他们不会下载完整的区块链，也不会验证所有之前的交易是否有效。相反，他们必须相信大多数完整节点是诚实的（即在他们的链副本中只包含有效块）。</strong></p><p><strong><img src="https://fuel-labs.ghost.io/content/images/2022/10/image-14.png" alt="img"></strong></p><p><strong>这被称为<em>诚实多数假设</em>，这也是大多数单体区块链容易受到 51% 攻击的原因。在单体模型下，由于需要诚实的大多数完整节点来验证区块链是否有效，因此轻客户端被迫信任大多数。如果超过一半的全节点不诚实，轻客户端无法知道这一点，因此他们最终会跟随一条无效的链。</strong></p><h3 id="诚实多数假设-可扩展性的限制"><a href="#诚实多数假设-可扩展性的限制" class="headerlink" title="诚实多数假设 - 可扩展性的限制"></a><strong>诚实多数假设 - 可扩展性的限制</strong></h3><p><strong>单体链的可扩展性受到其对这种诚实多数假设的依赖的严重限制。这是因为，为了增加交易吞吐量，必须增加块大小和&#x2F;或频率，以使更多交易能够在相同的时间内处理。这增加了全节点的资源需求（和相关成本）；更大&#x2F;更快的块 &#x3D; 更多的计算 &#x3D; 更高的成本。</strong></p><p><strong><img src="https://fuel-labs.ghost.io/content/images/2022/10/image-15.png" alt="img"></strong></p><p><strong>随着运行全节点成本的增加，更多实体将选择运行轻客户端，依靠越来越小的全节点网络来验证链的有效性。区块验证的日益集中化是对单体链安全性的主要威胁，因为更集中的验证者池更容易受到攻击，也更容易串通。</strong></p><hr><h2 id="模块化执行：解耦计算和验证"><a href="#模块化执行：解耦计算和验证" class="headerlink" title="模块化执行：解耦计算和验证"></a><strong>模块化执行：解耦计算和验证</strong></h2><p><strong>好消息是区块链系统可以摆脱依赖诚实多数假设的设计。为了避免这种单体设计的缺陷，模块化区块链堆栈将计算与验证分离。通过将执行（即计算）移出基础链（通常称为“父链”），可以在不影响去中心化的情况下实现规模扩大。</strong></p><h3 id="什么是模块化执行层？"><a href="#什么是模块化执行层？" class="headerlink" title="什么是模块化执行层？"></a><strong>什么是模块化执行层？</strong></h3><p><strong>在模块化区块链堆栈中，执行层负责计算——换句话说，处理事务和应用单独的状态转换。</strong></p><p><strong>Fuel<a href="https://fuel-labs.ghost.io/introducing-fuel-the-fastest-modular-execution-layer/">将</a>模块化执行层定义为：为模块化区块链堆栈设计的可验证计算系统。更具体地说，一种可验证欺诈或有效性的区块链（或其他计算系统），它利用模块化区块链来实现数据可用性。</strong></p><p><strong><img src="https://fuel-labs.ghost.io/content/images/2022/10/image-16.png" alt="img"></strong></p><p><strong>为了进一步澄清，如果计算系统：1) 不能证明欺诈或有效性，或 2) 不将数据可用性卸载到另一层，则它们不是模块化执行层。</strong></p><p><strong>与整体区块链一样，模块化执行层采用专门的区块生产者网络。这些实体处理执行事务和生成块的资源密集型过程。然而，与单体系统不同，验证不在执行层处理，而是在模块化区块链堆栈的较低级别处理。</strong></p><h3 id="验证-保持区块生产者诚实"><a href="#验证-保持区块生产者诚实" class="headerlink" title="验证 - 保持区块生产者诚实"></a><strong>验证 - 保持区块生产者诚实</strong></h3><p><strong>模块化执行的天才在于，只要验证（即区块验证）是去中心化的，计算（即区块生产）就不需要去中心化。可以增加块大小，从而导致产生块的节点集中化——但只要将验证解耦，无效块就不会被添加到链中。</strong></p><p><strong>但这是如何工作的？如果我们允许区块生产保持中心化，我们如何确保安全性？这就是模块化发挥作用的地方。</strong></p><p><strong>模块化执行层将资源密集型执行功能抽象给强大的区块生产者，这些区块生产者捆绑并执行批量交易，并定期将这些作为区块发布到父链（结算&#x2F;共识&#x2F;数据可用性层）。为了让这些区块生产者保持诚实，还有额外的非区块生产完整节点（通常称为“验证者”或“证明者”）下载并重新执行发布到父链的区块，以确保它们仅包含有效交易。</strong></p><p><strong>这些完整节点如何传达交易的有效性或无效性的细节取决于模块化执行层是采用乐观模型还是零知识模型。在乐观 MEL 的情况下，全节点仅在检测到无效交易时才采取行动（通过欺诈证明）。相反，在零知识 MEL 的情况下，全节点主动证明交易的有效性（通过有效性证明）。无论哪种情况，区块生产者提供的所有交易的有效性或无效性都在父链上证明，而不是在模块化执行层上证明。</strong></p><h3 id="一个例子：Optimistic模块化执行层的欺诈证明"><a href="#一个例子：Optimistic模块化执行层的欺诈证明" class="headerlink" title="一个例子：Optimistic模块化执行层的欺诈证明"></a><strong>一个例子：Optimistic模块化执行层的欺诈证明</strong></h3><p><strong>为了提供更深入的说明，让我们探讨乐观 MEL 的情况（假设所有交易都是有效的，除非另有证明）。即使模块化执行层上的单个完整节点检测到发布在父链上的块中的无效交易，它们也可以生成欺诈证明（在预定义的“争议解决窗口”内），以加密方式证明交易无效。</strong></p><p><strong>根据特定模块化堆栈的结构，这可以通过多种方式处理，例如：</strong></p><p><strong>在具有沉降层的模块化堆栈中：</strong></p><ul><li><strong>全节点将欺诈证明提交给结算层上的专用争议解决合约，该合约直接重新执行交易（请注意，这要求 MEL 交易的结构使其在结算层的 VM 上可欺诈证明以一种确定性的方式——例如，<a href="https://fuellabs.github.io/fuel-docs/master/technology/fraud_proofs.html">FuelVM 被设计为在 EVM 内可进行欺诈证明</a>，以便在以太坊上进行结算）。</strong></li><li><strong>如果交易无效，违规的区块生产者将受到惩罚（即他们损失资金），“举报人”将获得部分资金奖励，并且链的状态恢复到无效交易之前的状态。因为不能保证在无效交易之后的任何交易都对应于有效状态，所以这些后续交易被重新执行。</strong></li><li></li></ul><p><strong><a href="https://forum.celestia.org/t/rollups-on-celestia/55#optimistic-rollups-10">在没有沉降层的</a>模块化堆栈中：</strong></p><ul><li><strong>全节点通过对等网络传播欺诈证明，以警告轻客户端该块包含无效交易。使用欺诈证明作为出块人不诚实行为的证据，全节点可以在母链上提出惩罚交易，从而削减出块人的资金。</strong></li><li><strong>因为没有结算层来规定链的“规范”版本，恶意的全节点理论上可以选择不拒绝区块；但是，欺诈证明已经传达给轻客户端，因此他们知道不要遵循恶意的全节点版本的链。结果，社会共识保证了无效块将被拒绝。</strong></li><li></li></ul><p><strong>在任何一种情况下，由于验证过程是在父链上而不是在执行层上进行的，因此安全性被外包给了父链，这意味着执行层本身可以在较低的安全保证下运行。即使执行层 99% 的全节点是不诚实的，也只需要一个诚实的全节点来确保执行层只包含有效交易。</strong></p><p><strong>这意味着，模块化执行层（和 MEL 轻客户端）可以在一个<em>诚实的少数假设</em>上运行，而不是依赖于诚实的大多数完整节点。</strong></p><p><strong><img src="https://fuel-labs.ghost.io/content/images/2022/10/image-17.png" alt="img"></strong></p><p><em><strong>在模块化执行层上，轻客户端只需要依赖一个诚实的全节点即可保证链的有效性</strong></em></p><p><strong>无效区块只能由单体系统中的大多数完整节点恢复，而模块化系统中的单个完整节点可以通过使用欺诈&#x2F;有效性证明来强制恢复无效交易。</strong></p><h3 id="这如何实现可扩展性"><a href="#这如何实现可扩展性" class="headerlink" title="这如何实现可扩展性"></a><strong>这如何实现可扩展性</strong></h3><p><strong>允许在父链之外进行计算可以大幅增加交易吞吐量。块大小可以显着增加，而无需担心块生产的集中化，因为单独的块验证过程使块生产者保持诚实。</strong></p><p><strong>虽然较大的区块确实给执行验证的完整节点带来了更高的负担，但诚实的少数假设意味着该领域的集中化威胁较小，因为依赖不诚实多数的基于集中化的漏洞变得不可能。</strong></p><p><strong>轻客户端还可以在模块化架构下以显着更高的安全保证运行，因为欺诈证明使他们能够根据来自单个诚实完整节点的证明来识别无效交易（与单片系统相反，单片系统至少需要轻客户端信任一半的完整节点是诚实的）。</strong></p><p><strong><img src="https://fuel-labs.ghost.io/content/images/2022/10/image-18.png" alt="img"><em>模块化执行层上的轻客户端比其单片客户端具有更高的安全保证</em></strong></p><p><strong>此外，区块生产者知道任何恶意活动都会被检测到并导致罚没，因此他们甚至不太可能试图做出不诚实的行为。因此，执行层可以进行计算优化（即处理大量事务），同时依赖于模块化堆栈的安全优化较低级别。</strong></p><hr><h2 id="模块化执行：潜在挑战"><a href="#模块化执行：潜在挑战" class="headerlink" title="模块化执行：潜在挑战"></a><strong>模块化执行：潜在挑战</strong></h2><p><strong>这种模块化架构确实提出了一些额外的技术和博弈论挑战。</strong></p><h3 id="数据可用性"><a href="#数据可用性" class="headerlink" title="数据可用性"></a><strong>数据可用性</strong></h3><p><strong>虽然欺诈&#x2F;有效性证明使诚实的完整节点能够证明欺诈，但还有一个额外的问题：数据可用性。为了生成证明，全节点依赖于块可用性，因为它们需要下载并重新执行块中的所有交易以确定其有效性并生成证明。</strong></p><p><strong>理论上，恶意区块生产者可以只向父链发布区块头，可能会保留部分或全部相应数据。这可以防止完整节点能够生成欺诈&#x2F;有效性证明来提醒轻客户端注意问题。</strong></p><p><strong>当尝试验证一个块时，全节点很容易识别数据何时被恶意块生产者扣留。在这种情况下，他们可以简单地假设该链无效并从中分叉。但是轻客户端如何在不下载整个区块的情况下确定数据是否被区块生产者扣留了呢？</strong></p><p><strong>一种称为<a href="https://hackmd.io/@vbuterin/sharding_proposal#ELI5-data-availability-sampling">数据可用性采样</a>(DAS) 的新技术使轻客户端能够以概率方式确定是否已发布整个块。简而言之，轻客户端从完整节点请求块的小随机小部分（或“样本”）。</strong></p><p><strong><img src="https://fuel-labs.ghost.io/content/images/2022/10/image-19.png" alt="img"></strong></p><p><em>*<em>轻客户端从全节点请求区块的子集（“样本”）（来源：</em><a href="https://hackmd.io/@vbuterin/sharding_proposal#ELI5-data-availability-sampling"><em>Vitalik Buterin</em></a>*)</em>**</p><p><strong>如果所有请求的样本都可用，那么假设有足够多的轻客户端执行数据可用性采样，这在概率上证明了整个块是可用的。如果块的任何部分不可用，轻客户端知道数据已被保留，因此可以从该版本的链中分叉。</strong></p><p><strong>对这项技术的完整解释超出了本文的范围，但您可以<a href="https://www.paradigm.xyz/2022/08/das">在此处</a>阅读更多相关信息。最终，重要的一点是 DAS 使轻客户端能够识别无效块，即使恶意块生产者隐瞒数据也是如此。</strong></p><h3 id="验证者的困境"><a href="#验证者的困境" class="headerlink" title="验证者的困境"></a><strong>验证者的困境</strong></h3><p><strong>另一个潜在问题是被称为“验证者困境”的现象。简化版如下：</strong></p><ul><li><p><strong>如果区块生产者知道完整节点会识别不诚实的活动，他们会诚实行事以避免被削减。</strong></p></li><li><p><strong>随着时间的推移，如果全节点假设区块生产者将继续诚实行事，他们就没有动力继续验证区块，因为他们永远不会因识别无效交易而获得奖励。</strong></p></li><li><p><strong>如果全节点没有经济上的激励来继续验证区块，他们可能会停止这样做。在这一点上，区块生产者的不诚实行为变得可行。即使仍然存在非零数量的完整节点，对于区块生产者而言，贿赂剩余的完整节点以忽略足够有价值的无效交易可能在财务上是可行的。</strong></p></li></ul><p><strong>这以一个循环难题告终，即模块化执行层变得越安全（即区块生产者不诚实行为的动机越少），它就越倾向于降低安全性（即不再激励全节点验证区块） . 另一方面，它越不安全，它就越倾向于更高的安全性。</strong></p><p><strong><img src="https://fuel-labs.ghost.io/content/images/2022/10/image-22.png" alt="img"></strong></p><p><strong>可以通过多种途径缓解这种困境（有关这些因素的博弈论分析，<a href="https://medium.com/onther-tech/optimistic-rollup-is-not-secure-enough-than-you-think-cb23e6e6f11c">请参阅这篇广泛的帖子</a>）：</strong></p><ul><li><p><strong>利他主义——因为 MEL 只需要一个诚实的验证者，只要至少有一个利他主义全节点在运行，系统就会保持安全。然而，虽然这在实践中可能足够安全，但对于控制大量资产的系统来说，这并不是充分的保证。</strong></p></li><li><p><strong>经济利益——有许多实体拥有运行完整节点的经济激励，这超出了潜在的举报人奖励。例如，区块浏览器、流动性提供者或 dapp 等产品和服务需要访问 MEL 的完整状态才能有效地开展业务。然而，这些实体（理论上）容易受到恶意区块生产者的贿赂。</strong></p></li><li><p><strong>鲸鱼——在 MEL 上拥有大量资产的实体可以选择运行一个完整的节点，以确保他们的利益受到保护并且链是安全的。</strong></p></li><li><p><strong>快速取款- 因为乐观的 MEL 在保证模块化堆栈的较低层的最终确定性之前依赖于争议解决窗口，所以在此窗口过去之前，从 MEL 到结算层的取款不会最终确定。因此，存在提供快速提款、在 MEL 上接受代币并在结算层立即向用户发送相同代币（减去费用）的第三方服务市场。为了确保 MEL 状态在他们在结算层发送资金后不会恢复，激励服务提供商在进入此类交易之前验证链的有效性。</strong></p></li><li><p><strong>块生产者- 可以对提交构建在先前无效块之上的块的块生产者引入惩罚。有了这样的机制，区块生产者将被激励在提交区块之前验证链的有效性。</strong></p></li></ul><p><strong>虽然上述缓解策略本身可能并不完全有效，但当结合使用时，有明显的动机让许多不同的各方继续在 MEL 上运行完整节点并验证链的状态。</strong></p><hr><h2 id="新的设计空间：超越-EVM"><a href="#新的设计空间：超越-EVM" class="headerlink" title="新的设计空间：超越 EVM"></a><strong>新的设计空间：超越 EVM</strong></h2><p><strong>通过采用在单一诚实少数假设下实现高安全性的设计，模块化区块链堆栈能够开发比以前在单片设计下可能实现的更高吞吐量的区块链。</strong></p><p><strong>然而，除了计算与验证分离带来的可扩展性优势之外，还可以通过专门关注堆栈顶部的设计：模块化执行层，在可扩展性方面取得进一步进展。在这一层上使计算更具可扩展性和效率是构建更好的区块链的下一步。</strong></p><p><strong>目前正在开发的大多数模块化执行层都使用以太坊作为其父链，因此默认使用 EVM 作为执行环境。这相当于提高内燃机的能源效率的设计：对已经过时的技术进行增量改进。</strong></p><p><strong>实际上，模块化堆栈开辟了更广阔的设计空间，不再需要模块化执行层来依赖低效的 EVM。Fuel 正在利用这个新扩展的设计空间来构建一个<a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html">超越 EVM</a>的模块化执行层，优化高效和可扩展的计算、卓越的开发人员体验和最大的安全性。</strong></p><p><strong>在第 2 部分中，我们将探讨模块化执行层如何超越上一代区块链设计的技术限制以实现真正的可扩展性。</strong></p><hr><h2 id="跟着我们"><a href="#跟着我们" class="headerlink" title="跟着我们"></a><strong>跟着我们</strong></h2><ul><li><p><strong><a href="https://twitter.com/fuellabs_">推特</a></strong></p></li><li><p><strong><a href="http://discord.com/invite/xfpK4Pe">不和谐</a></strong></p></li><li><p><strong><a href="https://www.linkedin.com/company/fuel-labs/">领英</a></strong></p></li><li><p><strong><a href="https://www.youtube.com/channel/UCam2Sj3SvFSAIfDbP-4jWZQ">YouTube</a></strong></p></li></ul><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a><strong>关于我们</strong></h2><p><strong><a href="https://www.fuel.network/">Fuel</a>是模块化区块链堆栈的最快执行层。该技术功能强大且时尚，支持并行事务执行，为开发人员提供扩展所需的最高灵活吞吐量和最高安全性。开发人员选择<a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html">FuelVM</a>是因为其卓越的开发人员体验和超越 EVM 限制的能力。</strong></p><h2 id="成为贡献者"><a href="#成为贡献者" class="headerlink" title="成为贡献者"></a><strong>成为贡献者</strong></h2><ul><li><p><strong><a href="https://jobs.lever.co/fuellabs">探索我们目前的职位空缺</a></strong></p></li><li><p><strong><a href="https://1v1l4ftv9zy.typeform.com/fuelgrants">申请 Grant</a></strong></p></li><li><p><strong><a href="https://fuellabs.github.io/sway/v0.24.5/">学习sway</a></strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Fuel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fuel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solidity中的数值类型</title>
      <link href="/2022/10/14/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/10/14/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-布尔型"><a href="#1-布尔型" class="headerlink" title="1.布尔型"></a>1.布尔型</h2><pre><code class="solidity">bool public _bool = true;bool public __bool = false;</code></pre><h2 id="2-整型"><a href="#2-整型" class="headerlink" title="2.整型"></a>2.整型</h2><pre><code class="solidity">int public _int = -1; // 整数，包括负数uint public _uint = 1; // 正整数uint256 public _number = 20220330; // uint256 0-2**256-1</code></pre><p><strong>比较运算符（返回布尔值）：<code>&lt;=</code>， <code>&lt;</code>， <code>==</code>， <code>!=</code>， <code>&gt;=</code>， <code>&gt;</code></strong></p><p><strong>算数运算符： <code>+</code>， <code>-</code> ，<code>*</code>， <code>/</code>， <code>%</code>（取余），<code>**</code>（指数）</strong></p><h2 id="3-地址类型"><a href="#3-地址类型" class="headerlink" title="3. 地址类型"></a>3. 地址类型</h2><p><strong>地址类型(address)存储一个 20 字节的值（以太坊地址的大小）。</strong></p><p><strong>地址类型也有成员变量，并作为所有合约的基础。</strong></p><p><strong>有普通的地址和可以转账<code>ETH</code>的地址（<code>payable</code>）。<code>payable</code>的地址拥有<code>balance</code>和<code>transfer()</code>两个成员，方便查询<code>ETH</code>余额以及转账。</strong></p><h2 id="4-定长字节数组"><a href="#4-定长字节数组" class="headerlink" title="4. 定长字节数组"></a>4. 定长字节数组</h2><p><code>byte</code> 是 <code>bytes1</code> 的别名。</p><blockquote><p><strong>可以将 byte[] 当作字节数组使用，但这种方式非常浪费存储空间，准确来说，是在传入调用时，每个元素会浪费 31 字节。 更好地做法是使用 bytes。</strong></p><p> <strong>定长<code>bytes</code>可以存一些数据，消耗<code>gas</code>比较少。</strong></p></blockquote><p>关键字有：<code>bytes1</code>， <code>bytes2</code>， <code>bytes3</code>， …， <code>bytes32</code>。</p><p>成员变量：</p><ul><li><code>.length</code> 表示这个字节数组的长度（只读）.</li></ul><pre><code class="solidity">// SPDX-License-Identifier: MIT//声明solidity版本 这行代码意思是源文件将不允许小于 0.8.4 版本或大于等于 0.9.0 版本的编译器编译pragma solidity ^0.8.4; contract Web3&#123;    //MiniSolidity变量以字节的方式存储进变量_byte32，转换成16进制为：0x4d696e69536f6c69646974790000000000000000000000000000000000000000        bytes32 public _byte32 = &quot;XiniSolidityS&quot;;        //_byte变量存储_byte32的第一个字节，为0x4d。    bytes1 public _byte = _byte32[0];         //_byte32.length的长度    uint public number = _byte32.length;&#125;</code></pre><h2 id="5-枚举-enum"><a href="#5-枚举-enum" class="headerlink" title="5. 枚举 enum"></a>5. 枚举 enum</h2><p><strong>枚举（<code>enum</code>）是<code>solidity</code>中用户定义的数据类型。它主要用于为<code>uint</code>分配名称，使程序易于阅读和维护</strong></p><p><strong><code>enum</code>的一个比较冷门的变量，几乎没什么人用。</strong></p><pre><code class="solidity">    // 用enum将uint 0， 1， 2表示为Buy, Hold, Sell    enum ActionSet &#123; Buy, Hold, Sell &#125;    // 创建enum变量 action    ActionSet action = ActionSet.Buy;</code></pre><pre><code class="solidity">pragma solidity ^0.8.4; contract HelloWeb3&#123;    // 用enum将uint 0， 1， 2表示为Buy, Hold, Sell    enum ActionSet &#123; Buy, Hold, Sell &#125;    // 创建enum变量 action    ActionSet action = ActionSet.Hold;    // enum可以和uint显式的转换  返回ActionSet.Hold = 1    function enumToUint() external view returns(uint)&#123;        return uint(action);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solidity </category>
          
          <category> 变量 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Web3</title>
      <link href="/2022/10/14/Hello%20Web3/"/>
      <url>/2022/10/14/Hello%20Web3/</url>
      
        <content type="html"><![CDATA[<pre><code class="solidity">// SPDX-License-Identifier: MIT//声明solidity版本 这行代码意思是源文件将不允许小于 0.8.4 版本或大于等于 0.9.0 版本的编译器编译pragma solidity ^0.8.4; contract HelloWeb3&#123;    string public _Hello = &quot;Hello Web3&quot;;&#125;</code></pre><p><strong>开发者工具：<a href="https://remix.ethereum.org/">remix.ethereum.org</a></strong></p><p><strong>学习网站：<a href="https://wtf.academy/">https://wtf.academy/</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> Solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>介绍Fuel Grants计划</title>
      <link href="/2022/10/13/%E4%BB%8B%E7%BB%8DFuel%20Grants%E8%AE%A1%E5%88%92/"/>
      <url>/2022/10/13/%E4%BB%8B%E7%BB%8DFuel%20Grants%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>原文：<a href="https://fuel-labs.ghost.io/introducing-the-fuel-grants-program/">https://fuel-labs.ghost.io/introducing-the-fuel-grants-program/</a></strong></p><p><strong>翻译者：FeiDan</strong></p></blockquote><blockquote><p><strong>Fuel Labs 向基于最快模块化执行层 Fuel 的开发人员和创建者提供 1 万至 15 万美元不等的开发者grant。</strong></p></blockquote><p><strong><img src="https://fuel-labs.ghost.io/content/images/size/w2000/2022/10/FuelGrants.png" alt="Introducing the Fuel Grants Program"></strong></p><h2 id="申请-grant-在这"><a href="#申请-grant-在这" class="headerlink" title="申请 grant 在这"></a><strong>申请 grant <a href="https://1v1l4ftv9zy.typeform.com/fuelgrants">在这</a></strong></h2><p><strong>今年早些时候，我们推出了最快的模块化执行层 Fuel v2。 随着 Fuel v2 的发展，我们已经开始摆脱传统的单体结构，在这种结构中，区块链的所有方面（共识、数据可用性和执行）都在单层上处理。</strong></p><p><strong>Fuel VM 的引入通过 UTXO 的并行化提供了令人难以置信的高水平吞吐量。 FuelVM 从以太坊生态系统中学习，多年来对以太坊 VM (EVM) 提出的改进，但由于需要保持向后兼容性而无法实施。 我们已经看到对 Fuel 的兴趣急剧上升，特别是有兴趣与我们一起构建模块化未来的开发人员。</strong></p><p><strong>从去中心化交易所到借贷市场、预言机、NFT 项目等等，Fuel 生态系统正在显着增长。 我们已经有大量的项目在建，包括：</strong></p><p><strong><img src="https://fuel-labs.ghost.io/content/images/2022/10/GrantedApps-3.png" alt="img"></strong></p><ul><li><p><strong><a href="https://elix.finance/#">Elix</a> - 一个先进的去中心化交易所，对bonding curves 进行深入研究  - <a href="https://twitter.com/elixfinance">Twitter</a></strong></p></li><li><p><strong><a href="https://microchain.systems/">Microchain</a> - 一种低成本、易于使用的代币兑换端，具有两大优势……多功能性和简单性 - <a href="https://twitter.com/MicrochainSys">Twitter</a></strong></p></li><li><p><strong><a href="https://www.unic.io/">UNIC</a> - 将现实世界的物品以 NFT 的形式上链 - <a href="https://twitter.com/0xUNIC">Twitter</a></strong> </p></li><li><p><strong><a href="https://twitter.com/fuelnomen">Fuel Nomen</a> - Fuel 的去中心化域名服务</strong></p></li><li><p><strong>Thunder - 一个完全在链上的NFT市场，允许批量上市和购买，强调用户的UX&#x2F;UI体验。</strong></p></li><li><p><strong><a href="https://docs.poolsharks.io/">Poolsharks</a> - OceanBook 是一个开源的 web3 协议，它使用户、protocols和 DAO 可以在一个聚合订单簿中轻松 设置 limit orders。- <a href="https://twitter.com/poolsharks_labs">Twitter</a></strong></p></li><li><p><strong><a href="https://acumen.network/">Acumen</a> -Acumen 连接 DeFi 和传统金融，使成千上万的中小企业和企业家获得资本的机会民主化，同时允许加密货币贷方获得有吸引力、稳定和uncorrelated收益 - <a href="https://twitter.com/acumenofficial">Twitter</a></strong></p></li><li><p><strong><a href="https://orao.network/">Orao</a> - 用于定制数据馈送的Oracle服务 - <a href="https://twitter.com/OraoNetwork">Twitter</a></strong></p></li></ul><h2 id="什么是Fuel补助计划？"><a href="#什么是Fuel补助计划？" class="headerlink" title="什么是Fuel补助计划？"></a><strong>什么是Fuel补助计划？</strong></h2><p><strong>Fuel补助计划旨在支持以Fuel为基础的项目。目前，我们向开发人员、创建者以及新的或现有的项目提供 10,000 美元至 150,000 美元不等的赠款，以在世界上最快的模块化执行层上进行构建。</strong></p><p><strong>我们欢迎所有对去中心化、web3 和构建模块化未来充满热情的建设者。我们设想一个 自主的未来，建立系统来为下一代人类协调与合作提供动力。基于 Fuel 的构建意味着摆脱单一区块链的限制。</strong></p><p><strong>但是，赠款计划不仅限于您在这篇文章中看到的内容；但会随着时间的推移而发展。随着我们生态系统内部和外部的兴趣不断增长，我们将花时间倾听人们建设的声音，了解他们对生态系统的需求和需求。这个生态系统不是由我们定义的，而是由在其中构建的项目定义的。</strong></p><h2 id="申请流程"><a href="#申请流程" class="headerlink" title="申请流程"></a><strong>申请流程</strong></h2><h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a><strong>类别</strong></h3><p><strong>Fuel 是一个新兴的生态系统，我们正在寻找各种令人兴奋的项目来构建我们的协议。申请资助时，请考虑以下类别，特别是您的项目适合的地方。请注意，仍然欢迎不适合特定类别的项目申请！</strong></p><ul><li><p><strong>协议开发</strong></p></li><li><p><strong>应用程序和集成（ DeFi 应用程序）</strong></p></li><li><p><strong>基础设施</strong></p></li><li><p><strong>开发者工具</strong></p></li><li><p><strong>审计</strong></p></li><li><p><strong>社区（营销和教育）</strong></p></li><li><p><strong>活动和黑客马拉松</strong></p></li></ul><h3 id="申请标准和指南"><a href="#申请标准和指南" class="headerlink" title="申请标准和指南"></a><strong>申请标准和指南</strong></h3><p><strong>申请生态系统补助时，您将被要求提供以下信息：</strong></p><ul><li><p><strong>项目名称;</strong></p></li><li><p><strong>项目描述和阶段；</strong></p></li><li><p><strong>为什么要在 Fuel 上构建，以及您的项目如何使 Fuel 受益；</strong></p></li><li><p><strong>你的项目范围和阶段性目标；</strong></p></li><li><p><strong>有多少人在做这个项目；</strong></p></li></ul><p><strong>此外：</strong></p><ul><li><strong>所有项目都必须承诺通过 MIT 或 Apache Licensing 开源。</strong></li><li><strong>我们不要求开发者公开，但要获得资金，我们需要进行身份验证。</strong></li></ul><p><strong>我们欢迎处于不同开发阶段的项目的应用程序，从早期构思到 MVP 及以后。我们也很想听听已经在其他链上构建的项目也想部署在 Fuel 上。</strong></p><h2 id="审核流程"><a href="#审核流程" class="headerlink" title="审核流程"></a><strong>审核流程</strong></h2><p><strong>我们会滚动审核申请，并在完成内部审核后与您联系。此过程最多可能需要两周时间，我们可能会在此期间与您联系以了解有关您的申请的任何说明。</strong></p><p><strong>Fuel 团队随后会联系您安排面试，并在此之后确认我们对申请的决定。如果您的申请获得批准，我们将通过入职流程与您合作，为项目建立某些里程碑，并让您开始在 Fuel 上进行构建！</strong></p><h2 id="申请"><a href="#申请" class="headerlink" title="申请"></a><strong>申请</strong></h2><p><strong>要申请补助金，请填写<a href="https://1v1l4ftv9zy.typeform.com/fuelgrants">此</a>表格。</strong></p><p><strong>我们非常高兴能够启动这个赠款计划，看到你们中的更多人在 Fuel 上构建， 并采取modular-pill。如果您有任何其他问题，请随时<a href="mailto:grants@fuel.sh">联系 grants@fuel.sh</a>。</strong></p><h2 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a><strong>关注我</strong></h2><ul><li><p><a href="https://twitter.com/fuellabs_"><strong>Twitter</strong></a></p></li><li><p><a href="http://discord.com/invite/xfpK4Pe"><strong>Discord</strong></a></p></li><li><p><a href="https://www.linkedin.com/company/fuel-labs/"><strong>LinkedIn</strong></a></p></li><li><p><a href="https://www.youtube.com/channel/UCam2Sj3SvFSAIfDbP-4jWZQ"><strong>YouTube</strong></a></p></li></ul><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a><strong>关于我们</strong></h2><p><strong><a href="https://www.fuel.network/">Fuel</a>是模块化区块链堆栈的最快执行层。该技术功能强大且时尚，支持并行事务执行，为开发人员提供扩展所需的最高灵活吞吐量和最高安全性。开发人员选择<a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html">FuelVM</a>是因为其卓越的开发人员体验和超越 EVM 限制的能力。</strong></p><h2 id="成为贡献者"><a href="#成为贡献者" class="headerlink" title="成为贡献者"></a><strong>成为贡献者</strong></h2><ul><li><strong><a href="https://jobs.lever.co/fuellabs">探索我们目前的职位空缺</a></strong></li><li><strong><a href="https://1v1l4ftv9zy.typeform.com/fuelgrants">申请grant</a></strong></li><li><strong><a href="https://fuellabs.github.io/sway/v0.24.5/">学习sway</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Fuel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fuel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Altlayer 解决了什么问题</title>
      <link href="/2022/10/13/AltLayer%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/"/>
      <url>/2022/10/13/AltLayer%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>作者：FeiDan</strong></p><p><strong>官网：<a href="https://altlayer.io/">https://altlayer.io/</a></strong></p><p><strong>参考资料：<a href="https://medium.com/@AltLayerCN">https://medium.com/@AltLayerCN</a></strong></p></blockquote><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h1><p><strong>AltLayer项目由jiayaoqi博士-Parity Asia前总监、Polkadot亚洲技术总监、Zilliqa联合创始人成立</strong></p><p><strong>AltLayer从该领域一些最聪明的 VC 和天使那里筹集了 720 万美元。本轮融资由 Polychain Capital、Jump Crypto 和 Breyer Capital 牵头。前 Coinbase 首席技术官和 a16z GP Balaji Srinivasan，Circle 联合创始人兼 USDC 架构师 Sean Neville，以太坊联合创始人兼 Parity Technologies 首席执行官 Gavin Wood，Messari 创始人 Ryan Selkis，Synthetix 联合创始人 Kain Warwick 和 Jordan Momtazi（Bodhi Ventures），前 Polychain GP Tekin Salimi (DAO5) 等也以天使身份投资。</strong></p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a><strong>案例</strong></h1><ol><li><strong>Yuga Labs（CryptoPunks背后的实体）在Otherdeed for Otherside公开发售时，gas费飙升到2.5E（平均gas费），一度导致ETH网络瘫痪。高额的gas费带来的是用户体验不友好，他们正在寻求将该项目迁移到自己的链上，以便进行扩展。即使Apecoin社区拒绝了脱离以太坊的提议，但仍有约47%的社区成员投票支持ApeChain。</strong></li><li><strong>dYdX — 以太坊上最大的去中心化衍生品交易所宣布将要在cosmos上建立自己的链，并使用Cosmos SDK有自己的一套验证器。</strong></li><li><strong>黑暗森林游戏是一款纯链上游戏，用户的每一步操作都要在链上进行广播。庞大的用户群体和频繁的交易导致链上手续费激增，交易速度缓慢。</strong></li></ol><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h1><p><strong>AltLayer可以部署在任何链上，从底层L1&#x2F;L2&#x2F;XX上获取安全性。</strong></p><p><strong>AltLayer 是一个由多个类似于optimistic rollup的执行层（称为flash layers 闪电层）组成的系统。提供了一个20000TPS的Flash Layer 来解决热门NFT MINT 事件。</strong></p><p><strong>有一些热门dApps不需要永恒的专用区块空间，而只需要在预期需求激增的短时期内。例如，涉及NFT铸币的Yuga Labs案例是一个短暂的事件。</strong></p><p><strong>Altlayer的思路就像是把Rollup的方案当做云计算资源一样来使用，Rollup方案只有在DApp预计有相当大的访问需求，且一层网络无法处理时才会被调用。一旦需求逐渐减少，DApp就可以移回L1网络。</strong></p><p><strong>事实上大多数NFT MINT 事件在几小时&#x2F;几天就可以结束，当NFT MINT 事件发生用户激增。可以采取ALtLayer的NFT 解决方案</strong></p><p><strong><img src="https://miro.medium.com/max/700/1*ygTcmrIljx-z6VbyWRaADA.png" alt="img"></strong></p><p><strong><a href="https://altlayer.io/nft-solution">https://altlayer.io/nft-solution</a></strong></p><p><strong>一旦NFT MINT活动结束，用户活动就会缓慢，以至于从二级市场（opensea&#x2F;X2Y2等等）或其他活动中产生的交易量可以被任何blockchain轻松处理。</strong></p><blockquote><p><strong>FlashLayer具体来看，其应对方式如下：</strong></p><p><strong>1.快速启动一个由一层网络（如以太坊）保证安全性的Rollup解决方案。</strong></p><p><strong>2.合理利用Rollup解决方案，从而防止一层网络的空间堵塞。</strong></p><p><strong>3.通过在一层网络进行 “end-of-life ”的结算程序来结束Rollup解决方案的调用。</strong></p></blockquote><p><strong>dYdX — 以太坊上最大的去中心化衍生品交易所宣布将要在cosmos上建立自己的链,建立自己的链会消耗大量的精力和财力，并且面临流动性不足和安全方面的问题.</strong></p><p><strong>假如dYdX迁移到AltLayer链上,能给他们带来什么好处？</strong></p><ol><li><strong>低gas费</strong></li><li><strong>hyper-scalable的一次性执行层，它依赖于类似于optimistic rollups的optimistic执行层。</strong></li><li><strong>安全性</strong></li></ol><h1 id="什么时候推出？"><a href="#什么时候推出？" class="headerlink" title="什么时候推出？"></a><strong>什么时候推出？</strong></h1><p><strong>自 2021 年第四季度以来，我们一直在构建 AltLayer，我们很高兴地宣布，我们已经准备好功能齐全的 MVP 和 devnet。那些有兴趣了解 AltLayer 如何工作的人，请查看这篇关于一次性执行层上的第一个 NFT 铸造事件的<a href="https://medium.com/altlayer/the-first-nft-mint-event-on-altlayer-has-concluded-cc0a1926268c">博客文章。</a>我 <a href="https://medium.com/@AltLayerCN/altlayer-alpha%E5%BC%80%E5%8F%91%E7%BD%91-8774637ef9eb">alpha 测试网</a>已经推出，其中包含几个重要的里程碑。</strong></p>]]></content>
      
      
      <categories>
          
          <category> AltLayer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AltLayer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解 Fuel 背后的团队</title>
      <link href="/2022/10/12/%E4%BA%86%E8%A7%A3%20Fuel%20%E8%83%8C%E5%90%8E%E7%9A%84%E5%9B%A2%E9%98%9F/"/>
      <url>/2022/10/12/%E4%BA%86%E8%A7%A3%20Fuel%20%E8%83%8C%E5%90%8E%E7%9A%84%E5%9B%A2%E9%98%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>原文：<a href="https://fuel-labs.ghost.io/meet-the-team-episode-1/">https://fuel-labs.ghost.io/meet-the-team-episode-1/</a></strong></p><p><strong>翻译者：FeiDan</strong></p><p><strong>在我们的 “认识Fuel背后的团队 “系列的第一集，我们很高兴听到Fuel Labs和Celestia Labs的联合创始人John Adler的发言。</strong></p></blockquote><p><img src="https://fuel-labs.ghost.io/content/images/size/w2000/2022/06/Picture-1-1.png" alt="Meet the team behind Fuel"></p><h3 id="序列1-John-Adler-Fuel-Labs的联合创始人"><a href="#序列1-John-Adler-Fuel-Labs的联合创始人" class="headerlink" title="序列1 John Adler, Fuel Labs的联合创始人"></a><strong>序列1 John Adler, Fuel Labs的联合创始人</strong></h3><blockquote><p>**在我们的 “<em>认识Fuel背后的团队 “<em>系列的第一集，我们很高兴听到<a href="https://twitter.com/jadler0">John Adler</a>，<a href="https://twitter.com/jadler0">Fuel Labs</a>和<a href="https://twitter.com/jadler0">Celestia Labs</a>的联合创始人的介绍。</em></em></p></blockquote><h3 id="请告诉我们你的背景以及你在区块链和工程方面的经验。"><a href="#请告诉我们你的背景以及你在区块链和工程方面的经验。" class="headerlink" title="请告诉我们你的背景以及你在区块链和工程方面的经验。"></a><strong>请告诉我们你的背景以及你在区块链和工程方面的经验。</strong></h3><p><strong>我之前在<a href="https://consensys.net/">ConsenSys</a>做第二层可扩展性研究，在那里我创造了 optimistic rollup 设计范例。<a href="https://twitter.com/musalbas">Mustafa Al-Bassam</a>关于欺诈和数据可用性证明（现在的数据可用性采样）和LazyLedger的论文极大地启发了我的研究。</strong></p><p><strong>在此之前，我在多伦多大学进行电子和计算机工程的研究生学习，侧重于形式化方法。</strong></p><h3 id="您是如何创建-Fuel-的？"><a href="#您是如何创建-Fuel-的？" class="headerlink" title="您是如何创建 Fuel 的？"></a><strong>您是如何创建 Fuel 的？</strong></h3><p><strong>Nick 和我早在 2019 年年中就启动了 Fuel v1，作为对当时困扰Ethereum的扩展问题的第一个optimistic rollup 设计范例。 它最初专注于稳定币支付，这是当时最大的gas。 很快就很明显，还需要可扩展的图灵完备智能合约，因此我们在 Fuel v1 主网启动后不久就开始了 Fuel v2（即 Fuel）的工作。</strong></p><h3 id="您在Fuel公司的日常工作是什么？"><a href="#您在Fuel公司的日常工作是什么？" class="headerlink" title="您在Fuel公司的日常工作是什么？"></a><strong>您在Fuel公司的日常工作是什么？</strong></h3><p><strong>我审查PR并修复CI故障 😂</strong></p><h3 id="你目前在做什么工作？"><a href="#你目前在做什么工作？" class="headerlink" title="你目前在做什么工作？"></a><strong>你目前在做什么工作？</strong></h3><p><strong>大多数情况下，我正在努力：</strong></p><ol><li><strong>对Fuel VM的改进，以回应使用Sway的开发者的要求，以及</strong></li><li><strong>Sway标准库的新功能。</strong></li></ol><h3 id="你是如何进入区块链的以及什么让你最兴奋？"><a href="#你是如何进入区块链的以及什么让你最兴奋？" class="headerlink" title="你是如何进入区块链的以及什么让你最兴奋？"></a><strong>你是如何进入区块链的以及什么让你最兴奋？</strong></h3><p><strong>我第一次接触区块链是在研究生院，因为我的导师参与了Ethereum的早期工作。当时吸引我的是区块链技术与编译器和虚拟机的接近，尽管这不是我的正式研究领域，但却是我内心深处的一个话题。</strong></p><h3 id="你还欣赏哪个区块链项目，为什么？"><a href="#你还欣赏哪个区块链项目，为什么？" class="headerlink" title="你还欣赏哪个区块链项目，为什么？"></a><strong>你还欣赏哪个区块链项目，为什么？</strong></h3><p><strong>比特币，因为它为整个空间铺平了道路。不幸的是，它的社区一直是它的败笔。</strong></p><h3 id="你有导师或你敬佩的人吗？"><a href="#你有导师或你敬佩的人吗？" class="headerlink" title="你有导师或你敬佩的人吗？"></a><strong>你有导师或你敬佩的人吗？</strong></h3><p><strong>导师，没有。至于我敬佩的人，那就是<a href="https://twitter.com/lightclients">lightclients</a>。我们曾经在 Quilt（ConsenSys 的一个团队）一起工作，从那时起，他们就在很短的时间内成为了改进以太坊不可或缺的一部分。</strong></p><h3 id="Fuel最让你兴奋的是什么？"><a href="#Fuel最让你兴奋的是什么？" class="headerlink" title="Fuel最让你兴奋的是什么？"></a><strong>Fuel最让你兴奋的是什么？</strong></h3><p><strong>一切。没有什么不令我兴奋的</strong></p><h3 id="你认为Fuel的未来是什么？"><a href="#你认为Fuel的未来是什么？" class="headerlink" title="你认为Fuel的未来是什么？"></a><strong>你认为Fuel的未来是什么？</strong></h3><p><strong>Fuel 是自主未来的引擎，将成为去中心化协调游戏的纽带。</strong></p><h3 id="区块链开发者为什么要来Fuel？"><a href="#区块链开发者为什么要来Fuel？" class="headerlink" title="区块链开发者为什么要来Fuel？"></a><strong>区块链开发者为什么要来Fuel？</strong></h3><p><strong>FuelVM 从 EVM 的缺点和教训中吸取了教训。如果你知道 EVM 是如何工作的，那么你就会知道 FuelVM 是如何工作的。它只是 EVM，多年来人们一直希望改进它，但由于向后兼容性而无法改进。</strong></p><p><strong>Sway 和 Forc 提供了无与伦比的开发者体验。虽然其他项目以他们的开发人员吃玻璃而自豪，但我们致力于让 Sway 开发人员吃棉花糖。</strong></p><h3 id="你认为区块链的未来是什么？怎样才能促进大规模采用？"><a href="#你认为区块链的未来是什么？怎样才能促进大规模采用？" class="headerlink" title="你认为区块链的未来是什么？怎样才能促进大规模采用？"></a><strong>你认为区块链的未来是什么？怎样才能促进大规模采用？</strong></h3><p><strong>未来几年，区块链技术将继续在全球舞台上获得重要性和相关性。然而，这需要扩展许多数量级，超出当今区块链的能力。</strong></p><h3 id="你的爱好是什么？"><a href="#你的爱好是什么？" class="headerlink" title="你的爱好是什么？"></a><strong>你的爱好是什么？</strong></h3><p><strong>等等，你们有什么爱好吗？</strong></p><h3 id="每天激励你的是什么？"><a href="#每天激励你的是什么？" class="headerlink" title="每天激励你的是什么？"></a><strong>每天激励你的是什么？</strong></h3><p><strong>在GitHub上被我们所有贡献者的 “10多个新通知 “通知吵醒。Fuel永不休眠。</strong></p><hr><h2 id="关注我们"><a href="#关注我们" class="headerlink" title="关注我们"></a><strong>关注我们</strong></h2><p><strong>如果您不想错过Fuel的任何更新，只需关注我们并开通-通知铃。</strong></p><ul><li><strong><a href="https://twitter.com/fuellabs_">Twitter</a></strong></li><li><strong><a href="http://discord.com/invite/xfpK4Pe">Discord</a></strong></li><li><strong><a href="https://www.linkedin.com/company/fuel-labs/">LinkedIn</a></strong></li><li><a href="https://www.youtube.com/channel/UCam2Sj3SvFSAIfDbP-4jWZQ"><strong>YouTube</strong></a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Fuel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fuel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fuel Labs宣布为最快的模块化执行层Fuel提供8000万美元的资助</title>
      <link href="/2022/10/11/Fule%20Labs%E5%AE%A3%E5%B8%83%E4%B8%BA%E6%9C%80%E5%BF%AB%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E6%89%A7%E8%A1%8C%E5%B1%82%E6%8F%90%E4%BE%9B8000%E4%B8%87%E7%BE%8E%E5%85%83%E7%9A%84%E6%94%AF%E6%8C%81/"/>
      <url>/2022/10/11/Fule%20Labs%E5%AE%A3%E5%B8%83%E4%B8%BA%E6%9C%80%E5%BF%AB%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E6%89%A7%E8%A1%8C%E5%B1%82%E6%8F%90%E4%BE%9B8000%E4%B8%87%E7%BE%8E%E5%85%83%E7%9A%84%E6%94%AF%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>原文：<a href="https://fuel-labs.ghost.io/fuel-labs-announces-80-million-of-support-for-the-fastest-modular-execution-layer/">https://fuel-labs.ghost.io/fuel-labs-announces-80-million-of-support-for-the-fastest-modular-execution-layer/</a></strong></p><p><strong>翻译者：FeiDan</strong></p></blockquote><p><strong><img src="https://fuel-labs.ghost.io/content/images/size/w2000/2022/09/Fuel_Trailer_Still_10.jpeg" alt="Fuel Labs Announces $80 Million of Support for the Fastest Modular Execution Layer"></strong></p><h3 id="With-over-60-engineers-Fuel-Labs-eyes-a-blockchain-with-maximum-security-and-the-highest-flexible-throughput-for-the-Ethereum-ecosystem"><a href="#With-over-60-engineers-Fuel-Labs-eyes-a-blockchain-with-maximum-security-and-the-highest-flexible-throughput-for-the-Ethereum-ecosystem" class="headerlink" title="With over 60 engineers, Fuel Labs eyes a blockchain with maximum security and the highest flexible throughput for the Ethereum ecosystem."></a><strong>With over 60 engineers, Fuel Labs eyes a blockchain with maximum security and the highest flexible throughput for the Ethereum ecosystem.</strong></h3><blockquote><p><strong>拥有60多名工程师，Fuel Labs为Ethereum生态系统提供一个具有最大安全性和最高灵活吞吐量的区块链。</strong></p></blockquote><p><strong>Fuel Labs today announced $80M USD of support led by Blockchain Capital and Stratos, with additional support from Alameda Research, CoinFund, Bain Capital Crypto, TRGC, Maven 11 Capital, Blockwall, Spartan, Dialectic, and ZMT. This marks a major milestone for modular execution layers in the blockchain community.</strong></p><blockquote><p>Fuel Labs今天宣布，由Blockchain Capital和Stratos牵头，Alameda Research、CoinFund、Bain Capital Crypto、TRGC、Maven 11 Capital、Blockwall、Spartan、Dialectic和ZMT提供的8000万美元支持。这标志着区块链社区的模块化执行层的一个重要里程碑。</p></blockquote><p><strong>There is an ongoing and significant shift happening in layer-1 (L1) blockchain architecture. The industry is moving away from a monolithic design—where consensus, data availability, and execution are tightly coupled—to a modular future, where execution is separated from data availability and consensus. The separation allows for specialization at each layer, delivering a significant increase in both bandwidth and execution capacity across the stack.</strong></p><blockquote><p>第一层（L1）区块链架构正在发生重大转变。该行业正在从单体设计——即共识、数据可用性和执行耦合度–转向模块化的未来，即执行与数据可用性和共识分离。这种分离允许每一层的特化，使整个堆栈的带宽和执行能力都有显著提高。</p></blockquote><p><strong><img src="https://fuel-labs.ghost.io/content/images/2022/09/Fuel_ModularLayer_Labels_Final_Compressed_cropped.png" alt="img"></strong></p><p><strong>Fuel demonstrates that developing new monolithic L1s in 2022 is short-sighted and that building high performance execution layers on top of modular blockchains can produce extremely high throughput with incredible Ethereum-grade security guarantees. Moreover, Fuel includes fraud-provable trust-minimized light clients which deliver better security and decentralization guarantees in addition to trust-minimized liquidity bridging, which is not possible between any two L1s.</strong></p><blockquote><p><strong>Fuel表明，在2022年开发新的L1是目光短浅，在模块化区块链之上构建高性能的执行层可以产生极高的吞吐量，并具有令人难以置信的以太坊级安全保证。此外，”Fuel “包括可验证的信任最小化的轻客户端，除了trust-minimized liquidity bridging以外，还提供更好的安全和去中心化保证，这在任何L1之间是不可能的。</strong></p></blockquote><p><strong>Furthermore, layer-2s (L2s) do not solve the scalability crisis either. Although L2s have opened up a margin of cost reduction for access to the Ethereum ecosystem, the total throughput increase has been modest. L2s have failed to keep costs low. The industry needs change that not only reduces waste and inefficiency, but opens up new kinds of use cases to birth the next generation of Defi. Fuel aims to resolve this by designing execution for the modular stack, namely, L1s with high bandwidth potential which features new styles of execution.</strong></p><blockquote><p><strong>此外，layer-2s (L2s) 也不能解决可扩展性危机。尽管 L2 为访问以太坊生态系统开辟了成本降低的余地，但总吞吐量的增长幅度不大。 L2 未能保持低成本。行业需要变革，不仅要减少浪费和效率低下，还要开辟新的用例来催生下一代 Defi。 Fuel 旨在通过设计模块化堆栈的执行来解决这个问题，即具有高带宽潜力的 L1，具有新的执行风格。</strong></p></blockquote><p><strong>“Fuel is designed specifically to leverage additional bandwidth in ways no other scalability system can. Fuel is the fastest execution layer for the modular blockchain stack, delivering the highest security and flexible throughput,” says Nick Dodson, Co-Founder of Fuel Labs. “Fuel defines a modular execution layer as: a verifiable computation system designed for the modular blockchain stack. Fuel specializes in making execution as efficient as possible.”</strong></p><blockquote><p><strong>Fuel 专门设计用于以其他可扩展系统无法实现的方式利用额外带宽。 Fuel 是模块化区块链堆栈的最快执行层，可提供最高的安全性和灵活的吞吐量，”Fuel Labs 的联合创始人 Nick Dodson 说。 “Fuel 将模块化执行层定义为：为模块化区块链堆栈设计的可验证计算系统。 Fuel 专注于尽可能提高执行效率</strong></p></blockquote><p><strong>“Our vision is to build the engine for the autonomous future, powering the next generation of independent human coordination and cooperation,” says John Adler, Co-Founder of Fuel Labs. “Sway was specifically designed to empower blockchain developers with the richest features and best possible developer experience. With Fuel, we can now go beyond monolithic.”</strong></p><blockquote><p><strong>我们的愿景是为自动驾驶的未来打造引擎，为下一代独立的人类协调与合作提供动力，”Fuel Labs 的联合创始人 John Adler 说。 “Sway 专门设计用于为区块链开发人员提供最丰富的功能和最佳的开发人员体验。有了 Fuel，我们现在可以超越单片式</strong></p></blockquote><p><strong>There are three central pillars to Fuel’s technology stack:</strong></p><ol><li><strong>Parallel transaction execution. More compute. More state access.</strong></li><li><strong>The Fuel Virtual Machine (FuelVM). Less waste. More flexibility.</strong></li><li><strong>A superior developer experience (with Sway and Forc). Powerful. Sleek.</strong></li></ol><blockquote><p><strong>Fuel公司的技术有三个核心支柱：。</strong>**</p><ol><li><strong>并行交易执行。更多的计算。更多的状态访问。</strong></li><li><strong>燃料虚拟机（FuelVM）。更少的浪费。更加灵活。</strong></li><li><strong>卓越的开发者体验（Sway和Forc）。强大的。巧妙的。</strong></li></ol></blockquote><p><strong>Fuel v1 began as a L2 scalability technology for a monolithic Ethereum. It was the first optimistic rollup on mainnet Ethereum, deployed at the end of 2020. The project has grown significantly since its humble inception, now boasting more than 60 of the best and brightest engineers, and support from some of the best blockchain firms and industry leaders.</strong></p><blockquote><p><strong>Fuel v1开始是一个单体以太坊的L2可扩展性技术。这是以太坊主网的第一次optimistic rollup的推出，在2020年底部署。该项目自成立以来已大幅增长，现在拥有60多名最优秀和最聪明的工程师，并得到一些最好的区块链公司和行业领导者的支持。</strong></p></blockquote><p><strong>About Fuel Labs</strong></p><p><strong>Fuel Labs is a global decentralized group of passionate developers building the future of blockchain scalability technology. As the leader in blockchain scaling innovation, its engineers created the optimistic rollup design paradigm and have contributed to advancing the frontier of rollup, blockchain virtual machine, and safe smart contract programming language research. Fuel Labs deployed the first-ever optimistic rollup to mainnet Ethereum in 2020.</strong></p><blockquote><p>关于Fuel Labs</p><p><strong>Fuel Labs 是一个由热情的开发人员组成的全球去中心化团队，致力于构建区块链可扩展性技术的未来。 作为区块链扩容创新的领导者，其工程师创建了optimistic rollup to 设计范式，并为推进 Rollup、区块链虚拟机和安全智能合约编程语言研究的前沿做出了贡献。 Fuel Labs 在 2020 年首次向以太坊主网部署了optimistic rollup 。</strong></p></blockquote><p><strong>Press Contact:</strong></p><p><strong>Ekram Ahmed</strong></p><p><strong><a href="mailto:&#101;&#x6b;&#114;&#97;&#109;&#x40;&#51;&#x65;&#x6b;&#118;&#46;&#99;&#111;&#109;">&#101;&#x6b;&#114;&#97;&#109;&#x40;&#51;&#x65;&#x6b;&#118;&#46;&#99;&#111;&#109;</a></strong>  </p><blockquote><p><strong>新闻媒体联系人：</strong></p><p><strong>Ekram Ahmed</strong></p><p><strong><a href="mailto:&#x65;&#107;&#x72;&#x61;&#x6d;&#64;&#51;&#x65;&#107;&#118;&#x2e;&#x63;&#111;&#x6d;">&#x65;&#107;&#x72;&#x61;&#x6d;&#64;&#51;&#x65;&#107;&#118;&#x2e;&#x63;&#111;&#x6d;</a></strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Fuel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fuel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AltLayer是伪需求还是独角兽</title>
      <link href="/2022/10/11/AltLayer%E6%98%AF%E4%BC%AA%E9%9C%80%E6%B1%82%E8%BF%98%E6%98%AF%E7%8B%AC%E8%A7%92%E5%85%BD/"/>
      <url>/2022/10/11/AltLayer%E6%98%AF%E4%BC%AA%E9%9C%80%E6%B1%82%E8%BF%98%E6%98%AF%E7%8B%AC%E8%A7%92%E5%85%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="AltLayer是伪需求还是独角兽"><a href="#AltLayer是伪需求还是独角兽" class="headerlink" title="AltLayer是伪需求还是独角兽"></a>AltLayer是伪需求还是独角兽</h1><h1 id="创始人"><a href="#创始人" class="headerlink" title="创始人"></a>创始人</h1><p><img src="https://miro.medium.com/max/418/1*HwdiUiqbVaoqQRhPwqvALQ.png" alt="http://jiayaoqi.com/"></p><p><strong>AltLayer项目由Parity Asia前总监、Polkadot亚洲技术总监、Zilliqa联合创始人&#x2F;CTO Dr.Yaoqi Jia领导。该团队由区块链资深人士和研究人员组成，他们都曾在Parity、Zilliqa和Synthetix工作。关于创始人的背景，在2022年之前，他还是在Parity Asia任职总经理，为他进入Web3提供了很好的资源，由此看来，Alt Research（AltLayer的开发团队）是一个很年轻的团队。</strong></p><p><strong>Yaoqi曾在2019年入选福布斯30以下亚洲30强榜单，他曾参与过东南亚的加密货币交易所等项目。</strong></p><p><strong>在2018年以前，他是新加坡国立大学的研究员，拥有计算机博士学位。他的介绍中说：他的研究兴趣涵盖区块链安全、分布式系统安全、网络安全&#x2F;隐私和网络安全等领域。他已经从网络和系统两个角度提出了保护网络基础设施的解决方案，例如，解决网络覆盖中的隐私&#x2F;共识问题以及识别网络浏览器中的新攻击&#x2F;漏洞。与此同时，Yaoqi的研究工作已发表在 CCS、USENIX Security、PETS、RAID、ESORICS 等。获得了 W2SP (2014) 和 ICCCS (2014) 的最佳论文奖。他的工作得到了包括谷歌和苹果在内的多家供应商的认可（Chrome 为 CVE-2014–7948，Safari 为 CVE-2015–5907），并受到了 Dailydot、Gizmodo 和 Techspot 等媒体的关注。</strong></p><h1 id="AltLayer"><a href="#AltLayer" class="headerlink" title="AltLayer"></a><strong>AltLayer</strong></h1><p><img src="https://miro.medium.com/max/700/1*3L6SZ0Xai-IY8RryJs2-NA.jpeg" alt="img"></p><p><strong>AltLayer从该领域一些最聪明的 VC 和天使那里筹集了 720 万美元。本轮融资由 Polychain Capital、Jump Crypto 和 Breyer Capital 牵头。前 Coinbase 首席技术官和 a16z GP Balaji Srinivasan，Circle 联合创始人兼 USDC 架构师 Sean Neville，以太坊联合创始人兼 Parity Technologies 首席执行官 Gavin Wood，Messari 创始人 Ryan Selkis，Synthetix 联合创始人 Kain Warwick 和 Jordan Momtazi（Bodhi Ventures），前 Polychain GP Tekin Salimi (DAO5) 等也以天使身份投资。</strong></p><p><img src="https://miro.medium.com/max/700/1*uN9H-vIK1F1wP2UtNfgkrw.png" alt="img"></p><p><strong>对比一下AltLayer与其他L2解决方案的优势</strong></p><h2 id="1-高吞吐量"><a href="#1-高吞吐量" class="headerlink" title="1.高吞吐量"></a><strong>1.高吞吐量</strong></h2><p><strong>AltLayer 20,000 TPS (For 10 layers)，在区块链里 TPS 指的就是一个区块链系统里每秒可以处理多少笔交易，吞吐量是区块链系统的一个重要技术指标，就像我们常把带宽作为 2&#x2F;3&#x2F;4&#x2F;5G 通信技术的指标一样。简单来说，高 TPS 对于公有链的意义就是路变得更宽了”。大家都知道路越宽车开得越舒服，也越不容易堵车，区块链也是同样的道理。</strong></p><h2 id="2-低的交易费用"><a href="#2-低的交易费用" class="headerlink" title="2.低的交易费用"></a><strong>2.低的交易费用</strong></h2><p><strong>在区块链中，你向另一个账户转账时需要支付一定的费用。</strong></p><h2 id="3-闪电层"><a href="#3-闪电层" class="headerlink" title="3.闪电层"></a><strong>3.闪电层</strong></h2><p><strong>在其核心，AltLayer 是一个由多个类似于optimistic rollup的执行层（称为flash layers 闪电层）组成的系统。</strong></p><p><strong>Altlayer的思路就像是把Rollup的方案当做云计算资源一样来使用，Rollup方案只有在DApp预计有相当大的访问需求，且一层网络无法处理时才会被调用。一旦需求逐渐减少，DApp就可以移回一层网络。</strong></p><p><strong>这种高度弹性的方案使得整个系统的资源得到了高度优化。至此，我们不妨把Altlayer要做的事情称为“Rollup as Service”。</strong></p><p><strong>具体来看，其应对方式如下：</strong></p><p><strong>1.快速启动一个由一层网络（如以太坊）保证安全性的Rollup解决方案。</strong></p><p><strong>2.合理利用Rollup解决方案，从而防止一层网络的空间堵塞。</strong></p><p><strong>3.通过在一层网络进行 “end-of-life ”的结算程序来结束Rollup解决方案的调用。</strong></p><p><strong>点击<a href="https://www.ethereum.cn/an-incomplete-guide-to-rollups">Rollup</a>了解更多知识</strong></p><p><strong>点击了解更多<a href="https://link.medium.com/suq3z2DVCrb">AltLayer应用案例</a></strong></p><h2 id="4-多链"><a href="#4-多链" class="headerlink" title="4.多链"></a><strong>4.多链</strong></h2><p><strong>AltLayer允许被部署在多条区块链上。</strong></p><h2 id="5-去中心化"><a href="#5-去中心化" class="headerlink" title="5.去中心化"></a><strong>5.去中心化</strong></h2><p><strong>在一个分布有众多节点的系统中，每个节点都具有高度自治的特征。节点之间彼此可以自由连接，形成新的连接单元。任何一个节点都可能成为阶段性的中心，但不具备强制性的中心控制功能。节点与节点之间的影响，会通过网络而形成非线性因果关系。这种开放式、扁平化、平等性的系统现象或结构，我们称之为去中心化。</strong></p><p><strong>随着主体对客体的相互作用的深入和认知机能的不断平衡、认知结构的不断完善，个体能从自我中心状态中解除出来，称之为去中心化。</strong></p><h2 id="6-EVM，WASM"><a href="#6-EVM，WASM" class="headerlink" title="6.EVM，WASM"></a><strong>6.EVM，WASM</strong></h2><p><strong>EVM支持solidity开发。</strong></p><p><strong>WASM支持 Rust 和 C++ 的开发。</strong></p><h2 id="7-MEV"><a href="#7-MEV" class="headerlink" title="7.MEV"></a><strong>7.MEV</strong></h2><p><strong>简而言之就是矿工对其所在区块的一切交易的顺序有控制权，能够随意控制交易的顺序，并以此来进行获取利益。例如夹子机器人</strong></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a><strong>结语</strong></h1><p><strong>关于“二层是伪需求”每个人都有自己的看法，但无可否认的事实是越来越多有条件的项目都在往二层迁移，从Sandbox到Yuga Labs，都在试图用发展二层网络的方式来解决扩展问题。</strong></p>]]></content>
      
      
      <categories>
          
          <category> AltLayer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AltLayer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合作伙伴研究：Squid 是每个人的跨链流动性</title>
      <link href="/2022/10/11/%E5%90%88%E4%BD%9C%E4%BC%99%E4%BC%B4%E7%A0%94%E7%A9%B6%EF%BC%9ASquid%20%E6%98%AF%E6%AF%8F%E4%B8%AA%E4%BA%BA%E7%9A%84%E8%B7%A8%E9%93%BE%E6%B5%81%E5%8A%A8%E6%80%A7/"/>
      <url>/2022/10/11/%E5%90%88%E4%BD%9C%E4%BC%99%E4%BC%B4%E7%A0%94%E7%A9%B6%EF%BC%9ASquid%20%E6%98%AF%E6%AF%8F%E4%B8%AA%E4%BA%BA%E7%9A%84%E8%B7%A8%E9%93%BE%E6%B5%81%E5%8A%A8%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>原文:<a href="https://axelar.network/blog/cross-chain-liquidity-via-squid">https://axelar.network/blog/cross-chain-liquidity-via-squid</a></strong></p><p><strong>翻译:FeiDan</strong></p></blockquote><blockquote><p><strong>Squid 是一种协议，可通过单个 Javascript 软件开发工具包 (SDK) 实现跨链流动性路由和交换。</strong></p></blockquote><p><strong>在开发了自己的 Web3 应用程序之后，从应用程序到共识级别，Squid 的创始人对构建可互操作的 Web3 应用程序的障碍和痛点有第一手的经验。这种经历激发了他们构建<a href="https://0xsquid.com/">Squid</a>的使命，即让开发人员尽可能轻松地利用跨链流动性。</strong></p><h1 id="什么是-Squid-协议以及它如何实现跨链流动性？"><a href="#什么是-Squid-协议以及它如何实现跨链流动性？" class="headerlink" title="什么是 Squid 协议以及它如何实现跨链流动性？"></a><strong>什么是 Squid 协议以及它如何实现跨链流动性？</strong></h1><p><strong>Squid 正在为开发人员和用户提供跨链的未来。对于开发人员而言，Squid 是一种协议，可通过单个 Javascript 软件开发工具包 (SDK) 实现跨链流动性路由和交换。通过将用户连接到 Web3 中任何位置的 dex 上的流动性池，此路由允许在所有受支持的链上交换任何代币。SDK 通过获取返回令牌传输<a href="https://docs.0xsquid.com/get-started/get-a-route">详细信息</a>和执行成本的路由来工作。然后，开发人员可以使用所需的签名者和路由执行传输。</strong></p><p><img src="https://miro.medium.com/max/700/0*6x0JrpIK3scD2bdS.png" alt="img"></p><p><strong>Squid 使用<a href="https://docs.axelar.dev/dev/gmp-overview">Axelar 的通用消息传递</a>功能来实现跨多个链的智能合约调用。使用Squid<a href="https://docs.0xsquid.com/get-started/set-your-transfer-parameters/multicall-wip">的多调用特性</a>，应用程序可以依次调用多个合约。用例可能包括使用另一个链上的 dex 交换令牌，然后在另一个 dApp 中使用获得的令牌。此功能提供了跨链流动性，并为用户和开发人员节省了时间，因为第二笔交易不需要签名。</strong></p><p><strong>这对用户意味着一键交易。他们不需要下载多个钱包来签署跨不同链的交易。用户可以从任何市场购买 NFT，在另一条链上玩游戏或使用多链 DeFi 协议进行交易，无需任何额外步骤。Squid 使 dApp 能够使用 Axelar 网络提供的安全性来获取跨链流动性并提供这种体验。</strong></p><h1 id="0xSquid-安全"><a href="#0xSquid-安全" class="headerlink" title="0xSquid + 安全"></a>0xSquid + 安全</h1><p><strong>让开发人员更容易为其应用程序添加跨链流动性并非没有挑战。每当从事任何跨链解决方案时，安全性都是重中之重。任何错误或漏洞都可能导致用户资金损失和协议可信度损失。</strong></p><p><strong>在研究了不同的解决方案后，Squid 的团队对 Axelar 网络提供的安全性充满信心。Squid 和 Axelar 采用“最小表面积”的安全方法。这意味着使用的智能合约仅执行路由流动性的逻辑，但本身并不持有流动性。</strong></p><p><strong>Squid 执行的交换仅通过受信任的自动货币制造商 (AMM) 执行，并且不会引入新的交换合约。路由是 Squid 的唯一关注点。Squid 合约和 SDK 完成了管理跨链逻辑的所有工作，确保一致地应用安全标准并最大限度地减少人为错误的表面积。</strong></p><p><strong>除了使用 Axelar 提供的权益证明验证器集之外，Squid 还对<a href="https://ackeeblockchain.com/">Ackee Blockchain的</a><a href="https://docs.0xsquid.com/welcome-to-gitbook/the-basics/security-and-audits">合同</a>进行了审计，并正在接受 Consensys Diligence 的第二次审计，以增加一层安全性。</strong></p><h1 id="构建Squid"><a href="#构建Squid" class="headerlink" title="构建Squid"></a>构建Squid</h1><p><img src="https://miro.medium.com/max/700/0*ra7anvCzISSEk6lz.png" alt="img"></p><p><strong>构建跨链协议需要测试。在每个参与链的主网上进行测试不仅成本高昂，而且违背了所有最佳实践。为了为 Squid 建立一个真实的测试环境，该团队需要分叉 6 条不同链的主网以及 Axelar 的本地实例。</strong></p><p><strong>对于他们可用的工具，这几乎是不可能的。在 Axelar 团队的帮助下，<a href="https://github.com/axelarnetwork/axelar-local-dev">Axelar Local Development</a>诞生了。Axelar-Local-Dev 创建 Axelar 网关的本地实例，并允许开发人员在受支持链的主网分叉上创建合约并在它们之间传递消息。这将创建一个本地环境来正确测试使用 Axelar 的任何跨链应用程序。</strong></p><p><strong>Axelar Local Development 让 Squid 的团队可以完全控制他们的开发环境。构建项目所需的合约和 API 的迭代时间和成本显着降低。现在团队可以模拟和理解其他主网应用程序与 Squid 交互的行为。</strong></p><h1 id="监控Squid"><a href="#监控Squid" class="headerlink" title="监控Squid"></a>监控Squid</h1><p><strong>在多条链上工作时，能够监控跨链的交易至关重要。这使开发人员能够了解协议的整体健康状况和网络中的瓶颈。对于 Squid 的团队来说，监控对于他们的协议开发和集成它的开发人员都很重要。</strong></p><p><strong>Axelarscan区块浏览器提供了一个用户界面和 API，已被证明是 Squid 团队工具集中非常有用的一部分。<a href="https://axelarscan.io/">Axelarscan</a> 允许用户查看 Axelar 网络的整体活动以及特定交易和链的信息。来源、目的地、资产和当前状态等交易详情可在<a href="https://axelarscan.io/transfers">Transfers Explorer</a>中找到。</strong></p><h1 id="Squid的下一步是什么"><a href="#Squid的下一步是什么" class="headerlink" title="Squid的下一步是什么"></a>Squid的下一步是什么</h1><p><strong>Squid 的一个主要目标是即时执行跨链交易。他们目前正在与 Axelar 的团队合作开发 Axelar Gateway 的新实施，以实现这一目标。在撰写本文时，跨链交易总是会增加延迟。至少，必须尊重源、桥接协议和目标链的确认时间。这导致需要<a href="https://axelar.network/blog/how-to-build-a-cross-chain-dapp-interop-architecture-101">跨链架构的新方法</a>。但是，在源链上提供证明后，正在开发使跨链交易能够立即在目标链上执行。这种级别的交易时间将为跨链应用带来新的能力。</strong></p><p><strong>Squid 的推出将成为 Axelar 生态系统的加速器，因为跨链流动性的采购变得像一个简单的 API 调用一样简单。开发人员将能够在 Axelar 上轻松构建更复杂的应用程序并跨链扩展 Web3。</strong></p><p><strong>如果您有兴趣帮助更多的开发人员在 EVM 链和 Cosmos 之间构建跨链应用程序，<a href="https://0xsquid.notion.site/Squid-Jobs-Board-193b7674b2be49c29d5bfe7907808090">Squid 团队正在招聘</a>！</strong></p><p>**有关 Squid 的更多信息和更新，请在<a href="https://twitter.com/0xsquid_">Twitter 上</a>关注他们并加入<a href="https://discord.com/invite/vrJE79aWm6">Discord**</a></p>]]></content>
      
      
      <categories>
          
          <category> Axelar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Axelar </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
